<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LeetCode笔记</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif:wght@400;700&family=Libre+Baskerville:wght@400;700&display=swap" rel="stylesheet">
    <!-- MathJax 支持 -->
     <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
     <script>
     MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']],
        processEscapes: true,
        processEnvironments: true
      },
      options: {
        skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
        processHtmlClass: 'tex2jax_process'
      },
      startup: {
        pageReady: function() {
          return MathJax.startup.defaultPageReady().then(function() {
            console.log('MathJax initial typesetting complete');
          });
        }
      }
    };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script" async></script>
</head>
<body>
    <nav class="sidebar">
        <ul id="toc">
<ul>
    <li><a href="#leetcode">LeetCode 算法笔记</a></li>
    <ul>
        <li><a href="#_1">工具类</a></li>
        <ul>
            <li><a href="#_2">二分查找</a></li>
            <ul>
                <ul>
                    <li><a href="#-1">查找给定值，存在则返回索引，否则返回-1</a></li>
                    <li><a href="#_3">查找最后一个小于给定元素的位置（下界）</a></li>
                    <li><a href="#_4">查找第一个大于给定元素的位置（上界）</a></li>
                </ul>
                <li><a href="#_5">链表快慢指针</a></li>
                <ul>
                    <li><a href="#_6">取链表中点</a></li>
                    <li><a href="#_7">找环形入口</a></li>
                </ul>
            </ul>
            <li><a href="#_8">滑动窗口</a></li>
            <li><a href="#_9">单调栈</a></li>
            <li><a href="#_10">单调队列</a></li>
            <li><a href="#_11">前缀和</a></li>
        </ul>
        <li><a href="#_12">树</a></li>
        <li><a href="#_13">动态规划</a></li>
        <ul>
            <li><a href="#dp">DP 问题分类大观</a></li>
            <li><a href="#dp_1">线性 DP</a></li>
            <ul>
                <li><a href="#_14">递推问题</a></li>
                <li><a href="#_15">连续子数组问题</a></li>
                <li><a href="#lis">最长递增子序列问题 LIS</a></li>
                <li><a href="#_16">逆序问题</a></li>
                <li><a href="#_17">双序列问题</a></li>
                <li><a href="#_18">二维线性问题</a></li>
            </ul>
            <li><a href="#dp_2">区间DP：子区间最优解</a></li>
            <ul>
                <li><a href="#_19">回文串类型</a></li>
                <li><a href="#_20">分割点类型</a></li>
            </ul>
            <li><a href="#_21">背包问题：选择与容量</a></li>
            <ul>
                <li><a href="#0-1">0-1 背包</a></li>
                <li><a href="#_22">完全背包</a></li>
            </ul>
            <li><a href="#dp_3">状态机 DP</a></li>
        </ul>
        <li><a href="#_23">技巧</a></li>
        <ul>
            <ul>
                <li><a href="#_24">数组元素的相互抵消运算</a></li>
                <li><a href="#_25">数学技巧</a></li>
                <ul>
                    <li><a href="#_26">矩阵旋转</a></li>
                    <li><a href="#_27">因式分解</a></li>
                    <li><a href="#_28">均值不等式</a></li>
                </ul>
            </ul>
        </ul>
    </ul>
</ul>
</ul>
</div>
    </nav>
    
    <main id="content">
        <section id="leetcode"><h1 id="leetcode">LeetCode 算法笔记</h1>
<p>自用算法笔记，服务于机考；可以当作题单使用</p>
<h2 id="_1">工具类</h2>
<h3 id="_2">二分查找</h3>
<h5 id="-1">查找给定值，存在则返回索引，否则返回-1</h5>
<p>
<div class="code-container">
<div class="code-tabs">
<button class="tab-btn active" data-lang="python">Python</button>
<button class="tab-btn" data-lang="cpp">C++</button>
</div>
<div class="code-blocks">
<pre class="code-block active" data-lang="python"><code class="language-python"># 迭代版本
def binary_search(nums, target):
    left, right = 0, len(nums) - 1
    while left &lt;= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        if nums[mid] &lt; target:
            left = mid + 1
        else:
            right = mid - 1
    return -1
# 递归版本
def binary_search(nums, target, left, right):
    if left &gt; right:
        return -1
    mid = (left + right) // 2
    if nums[mid] == target:
        return mid
    if nums[mid] &lt; target:
        return binary_search(nums, target, mid + 1, right)
    else:
        return binary_search(nums, target, left, mid - 1)</code></pre>
<pre class="code-block" data-lang="cpp"><code class="language-cpp">// 迭代版本
int binarySearch(vector&amp; nums, int target) {
    int left = 0, right = nums.size() - 1;
    while (left &lt;= right) {
        int mid = (left + right) / 2;
        if (nums[mid] == target)
            return mid;
        if (nums[mid] &lt; target)
            left = mid + 1;
        else
            right = mid - 1;
    }
    return -1;
}
// 递归版本
int binarySearch(vector&amp; nums, int target, int left, int right) {
    if (left &gt; right) {
        return -1;
    }
    int mid = (left + right) / 2;
    if (nums[mid] == target)
        return mid;
    if (nums[mid] &lt; target)
        return binarySearch(nums, target, mid + 1, right);
    else
        return binarySearch(nums, target, left, mid - 1);
}</code></pre>
</div>
</div>
</p>
<h5 id="_3">查找最后一个小于给定元素的位置（下界）</h5>
<p>找下界就是返回 <code>right</code>，<code>nums[mid] &lt; target</code> 是否使用严格不等号等价于是否返回的是等于值的位置</p>
<p>（记：找下界，往小找，找过头了给右值）</p>
<p>
<div class="code-container">
<div class="code-tabs">
<button class="tab-btn active" data-lang="python">Python</button>
<button class="tab-btn" data-lang="cpp">C++</button>
</div>
<div class="code-blocks">
<pre class="code-block active" data-lang="python"><code class="language-python"># 迭代版本
def lower_bound(nums, target):
    left = 0
    right = len(nums) - 1
    result = -1 # 如果所有元素都 &gt;= target，返回-1
    
    while left &lt;= right:
        mid = (left + right) // 2
        if nums[mid] &lt; target:
            result = mid # 记录当前找到的位置
            left = mid + 1
        else:
            right = mid - 1 
    return result
# 递归版本
def lower_bound(nums, target, left, right): 
    if left &gt; right:
        return right # 当left&gt;right时，right就是最后一个小于target的元素
    
    mid = (left + right) // 2
    if nums[mid] &lt; target:
        return lower_bound(nums, target, mid + 1, right)
    else:
        return lower_bound(nums, target, left, mid - 1)</code></pre>
<pre class="code-block" data-lang="cpp"><code class="language-cpp">// 迭代版本
int lower_bound(vector&lt;int&gt;&amp; nums, int target) {
    int left = 0;
    int right = nums.size() - 1;
    int result = -1; // 如果所有元素都 &gt;= target，返回-1
    
    while (left &lt;= right) {
        int mid = (left + right) / 2;
        if (nums[mid] &lt; target){
            result = mid; // 记录当前找到的位置
            left = mid + 1;
        }
        else
            right = mid - 1;
    }
    return result;
}
// 递归版本
int lower_bound(vector&lt;int&gt;&amp; nums, int target, int left, int right) {
    if (left &gt; right)
        return right; // 当left&gt;right时，right就是最后一个小于target的元素
    
    int mid = (left + right) / 2;
    if (nums[mid] &lt; target)
        return lower_bound(nums, target, mid + 1, right);
    else
        return lower_bound(nums, target, left, mid - 1);
}</code></pre>
</div>
</div>
</p>
<h5 id="_4">查找第一个大于给定元素的位置（上界）</h5>
<p>找上界就是返回 <code>left</code>，<code>nums[mid] &gt; target</code> 是否使用严格不等号等价于是否返回的是等于值的位置</p>
<p>（记：找上界，往大找，找过头了给左值）</p>
<p>
<div class="code-container">
<div class="code-tabs">
<button class="tab-btn active" data-lang="python">Python</button>
<button class="tab-btn" data-lang="cpp">C++</button>
</div>
<div class="code-blocks">
<pre class="code-block active" data-lang="python"><code class="language-python"># 迭代版本
def upper_bound(nums, target):
    left = 0
    right = len(nums) - 1
    result = len(nums) # 如果所有元素都 &lt;= target，返回数组长度
    
    while left &lt;= right:
        mid = (left + right) // 2
        if nums[mid] &gt; target:
            result = mid # 记录当前找到的位置
            right = mid - 1
        else:
            left = mid + 1
    return result
# 递归版本
def upper_bound(nums, target, left, right):
    if left &gt; right:
        return left # 当left&gt;right时，left就是第一个大于target的元素
    
    mid = (left + right) // 2
    if nums[mid] &gt; target:
        return upper_bound(nums, target, mid + 1, right)
    else:
        return upper_bound(nums, target, left, mid - 1)</code></pre>
<pre class="code-block" data-lang="cpp"><code class="language-cpp">// 迭代版本
int upper_bound(vector&lt;int&gt;&amp; nums, int target) {
    int left = 0;
    int right = nums.size() - 1;
    int result = nums.size(); // 如果所有元素都 &lt;= target，返回数组长度
    
    while (left &lt;= right) {
        int mid = (left + right) / 2;
        if (nums[mid] &gt; target){
            result = mid; // 记录当前找到的位置
            right = mid - 1;
        }
        else
            left = mid + 1;
    }
    return result;
}
// 递归版本
int upper_bound(vector&lt;int&gt;&amp; nums, int target, int left, int right) {
    if (left &gt; right) 
        return left; // 当left&gt;right时，left就是第一个大于target的元素
    
    int mid = (left + right) / 2;
    if (nums[mid] &gt; target)
        return upper_bound(nums, target, mid + 1, right);
    else
        return upper_bound(nums, target, left, mid - 1);
}</code></pre>
</div>
</div>
</p>
<h4 id="_5">链表快慢指针</h4>
<h5 id="_6">取链表中点</h5>
<p>
<div class="code-container">
<div class="code-tabs">
<button class="tab-btn active" data-lang="python">Python</button>
<button class="tab-btn" data-lang="cpp">C++</button>
</div>
<div class="code-blocks">
<pre class="code-block active" data-lang="python"><code class="language-python">while fast and fast.next:
	fast, slow = fast.next.next, slow.next
mid = slow.next</code></pre>
<pre class="code-block" data-lang="cpp"><code class="language-cpp">while (fast != nullptr &amp;&amp; fast-&gt;next != nullptr) {
    fast = fast-&gt;next-&gt;next;
    slow = slow-&gt;next;
}
ListNode* mid = slow-&gt;next;</code></pre>
</div>
</div>
</p>
<h5 id="_7">找环形入口</h5>
<p>
<div class="code-container">
<div class="code-tabs">
<button class="tab-btn active" data-lang="python">Python</button>
<button class="tab-btn" data-lang="cpp">C++</button>
</div>
<div class="code-blocks">
<pre class="code-block active" data-lang="python"><code class="language-python"># 此部分代码待实现</code></pre>
<pre class="code-block" data-lang="cpp"><code class="language-cpp">// 此部分代码待实现</code></pre>
</div>
</div>
</p>
<p><a href="https://leetcode.cn/problems/find-the-duplicate-number/">287. 寻找重复数 - 力扣（LeetCode）</a></p>
<h3 id="_8">滑动窗口</h3>
<p>滑动窗口仅适用于在状态判断上单调的数组，即右扩展（例如非负数求和，长度等）</p>
<p>滑动窗口双指针的核心逻辑：</p>
<ul>
<li>右指针右移：扩展窗口，为了满足覆盖目标</li>
<li>左指针左移：缩小窗口，为了满足最小约束</li>
</ul>
<p><a href="https://leetcode.cn/problems/minimum-window-substring/description">76. 最小覆盖子串 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/">209. 长度最小的子数组 - 力扣（LeetCode）</a></p>
<p>
<div class="code-container">
<div class="code-tabs">
<button class="tab-btn active" data-lang="python">Python</button>
<button class="tab-btn" data-lang="cpp">C++</button>
</div>
<div class="code-blocks">
<pre class="code-block active" data-lang="python"><code class="language-python">def minSubArrayLen(self, target: int, nums: List[int]) -&gt; int:
    l, r = 0, 0
    n = len(nums)
    nums_sum=0
    res = n+1
    for r in range(n):
        nums_sum+=nums[r]
        while nums_sum&gt;=target:
            if nums_sum&gt;=target: res=min(res, r-l+1)
            nums_sum-=nums[l]
            l+=1
    return res if res!= n+1 else 0</code></pre>
<pre class="code-block" data-lang="cpp"><code class="language-cpp">int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) {
    int l=0, r=0;
    int n = nums.size();
    int sum = 0;
    int res = n+1;
    for(r=0;r&lt;n;r++){
        sum+=nums[r];
        while(sum&gt;=target){
            if(sum&gt;=target) res=min(res, r-l+1);
            sum-=nums[l];
            l++;
        } 
    }
    return res==n+1? 0:res;
}</code></pre>
</div>
</div>
</p>
<h3 id="_9">单调栈</h3>
<p>​   在 $O(n)$ 内解决 “ 左 / 右边下一个更大 / 更小元素 ” 问题（广义：在一维数组中找第一个满足某种条件的数）：</p>
<ul>
<li>单调递增栈：从栈顶到栈底递增（口诀：<strong>递增栈找第一大</strong>）</li>
<li>满足递增：入栈时判断栈顶是否比自己<strong>小</strong>，如果是则弹出；直到<strong>栈空</strong>或栈顶<strong>不小于</strong>自身，入栈</li>
<li>当从左到右顺序遍历入栈时，入栈前的元素就是<strong>左边第一个比自己大的元素</strong></li>
<li>单调递减栈：从栈顶到栈底递减（口诀：<strong>递减栈找第一小</strong>）</li>
<li>入栈时判断栈顶是否比自己<strong>大</strong></li>
<li>如果是则弹出，直到栈顶<strong>不大于</strong>自身，入栈</li>
<li>当从左到右顺序遍历入栈时，入栈前的元素就是<strong>左边第一个比自己小的元素</strong></li>
</ul>
<p>​   单调栈是非常好用的数据结构，为了避免脑子卡住：</p>
<ul>
<li>
<p>先记住口诀：减小增大（顺着的）</p>
</li>
<li>
<p>再记模板：单调栈三部曲（重在理解）</p>
</li>
</ul>
<p>
<div class="code-container">
<div class="code-tabs">
<button class="tab-btn active" data-lang="python">Python</button>
<button class="tab-btn" data-lang="cpp">C++</button>
</div>
<div class="code-blocks">
<pre class="code-block active" data-lang="python"><code class="language-python"># 此部分代码待实现</code></pre>
<pre class="code-block" data-lang="cpp"><code class="language-cpp">while 栈非空 and 单调性不满足（这里是排除，排除不严格结果就严格）:
  	出栈
  if 栈空:	边界处理
  esle: r[i]=栈顶
  无条件入栈 a[i]</code></pre>
</div>
</div>
</p>
<ul>
<li>然后理解：单调栈的精髓在于<strong>单向遮盖</strong>：对于从左向右遍历的递减栈来说，当它遇到一个值，栈中所有比它大的值都会被踢出，这个值就相当于遮盖了它左边所有比它大的值，标记出了新的左侧下界，但又保留了比自己更小的值</li>
</ul>
<p>（一般在实际应用中维护的是索引，结果序列的初试默认值为 -1，最终值为 -1 则代表没有，也就是单向极值）：</p>
<p>
<div class="code-container">
<div class="code-tabs">
<button class="tab-btn active" data-lang="python">Python</button>
<button class="tab-btn" data-lang="cpp">C++</button>
</div>
<div class="code-blocks">
<pre class="code-block active" data-lang="python"><code class="language-python">def next_greater(nums):
    greater_stack = []
    answer = [-1]*len(nums)	# 初始化全 -1
    for i in range(len(nums)):
        while greater_stack and nums[i]&gt;nums[greater_stack[-1]]: # 栈底在末位
            index = greater_stack.pop()
            answer[index] = nums[i]
        greater_stack.append(i)
    return answer</code></pre>
<pre class="code-block" data-lang="cpp"><code class="language-cpp">vector nextGreater(vector&amp; nums) {
    stack greaterStack;
    vector answer(nums.size(), -1);  // 初始化全 -1
    for (int i = 0; i &lt; nums.size(); i++) {
        while (!greaterStack.empty() &amp;&amp; nums[i] &gt; nums[greaterStack.top()]) { // 栈底在末位
            int index = greaterStack.top();
            greaterStack.pop();
            answer[index] = nums[i];
        }
        greaterStack.push(i);
    }
    return answer;
}</code></pre>
</div>
</div>
</p>
<p>:star:<a href="https://leetcode.cn/problems/trapping-rain-water/description">42. 接雨水 - 力扣（LeetCode）</a></p>
<p>思路：按列求，每次只关注一列（而不是块区域，这个聚焦思想很重要），一个列能够接雨水的量：取决于：<code>min(左边的最高值，右边的最高值）-当前列高</code>，于是我们只需要获得：</p>
<ul>
<li>向左看的最高列数组<code>l</code></li>
<li>向右看的最高列数组<code>r</code></li>
<li>本列的高度输入（输入）<code>a</code></li>
</ul>
<p>​   就可以得到答案数组<code>res[i]=min(l[i],r[i])-a[i]</code>，对 <code>res</code> 的所有非 0 项求和即可</p>
<p>
<div class="code-container">
<div class="code-tabs">
<button class="tab-btn active" data-lang="python">Python</button>
<button class="tab-btn" data-lang="cpp">C++</button>
</div>
<div class="code-blocks">
<pre class="code-block active" data-lang="python"><code class="language-python">def trap(height):
    n = len(height)
    h = 0
    l, r, res = [0] * n, [0] * n, [0] * n
    for i in range(n):
        l[i] = h
        if height[i] &gt; h:
            h = height[i]
    h = 0
    for i in range(n-1, -1, -1):
        r[i] = h
        if height[i] &gt; h:
            h = height[i]
    ans = 0
    for i in range(n):
        res[i] = min(l[i], r[i]) - height[i]
        if res[i] &gt; 0:
            ans += res[i]
    return ans</code></pre>
<pre class="code-block" data-lang="cpp"><code class="language-cpp">int trap(vector&lt;int&gt;&amp; height) {
    int n = height.size();
    int h = 0;
    vector&lt;int&gt; l(n), r(n), res(n);
    for(int i=0;i&lt;n;i++){
        l[i] = h;
        if(height[i]&gt;h) h = height[i];
    }
    h = 0;
    for(int i=n-1;i&gt;=0;i--){
        r[i] = h;
        if(height[i]&gt;h) h = height[i];
    }
    int ans = 0;
    for(int i=0;i&lt;n;i++){
        res[i]=min(l[i], r[i]) - height[i];
        if(res[i]&gt;0) ans+=res[i];
    }
    return ans;
}</code></pre>
</div>
</div>
</p>
<p><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/description">84. 柱状图中最大的矩形 - 力扣（LeetCode）</a></p>
<p>经典单调栈题目</p>
<p>
<div class="code-container">
<div class="code-tabs">
<button class="tab-btn active" data-lang="python">Python</button>
<button class="tab-btn" data-lang="cpp">C++</button>
</div>
<div class="code-blocks">
<pre class="code-block active" data-lang="python"><code class="language-python">def largestRectangleArea(self, heights):
    # 对于i列，矩形大小为：左边最远不小于自己的，右边最远不小于自己的
    n = len(heights)
    if n == 0:
        return heights[0]  
    s = []
    left, right = [0] * n, [0] * n       
    # 从左往右，找左边严格小,严格单调递减栈
    for i in range(n):
        while s and heights[s[-1]] &gt;= heights[i]:
            s.pop()
        left[i] = -1 if not s else s[-1]
        s.append(i)
    s = []
    # 从右往左，找右边严格小,严格单调递减栈
    for i in range(n-1, -1, -1):
        while s and heights[s[-1]] &gt;= heights[i]:
            s.pop()
        right[i] = n if not s else s[-1]
        s.append(i)
    # 计算答案
    maxa = 0
    for i in range(n):
        maxa = max(maxa, heights[i] * (right[i] - left[i] - 1))  
    return maxa</code></pre>
<pre class="code-block" data-lang="cpp"><code class="language-cpp">int largestRectangleArea(vector&lt;int&gt;&amp; heights) {
    // 对于i列，矩形大小为：左边最远不小于自己的，右边最远不小于自己的
    int n = heights.size();
    if(n==0) return heights[0];
    stack&lt;int&gt; s;
    vector&lt;int&gt; left(n), right(n);
    // 从左往右，找左边严格小,严格单调递减栈
    for(int i=0;i&lt;n;i++){
        while(!s.empty() &amp;&amp; heights[s.top()]&gt;=heights[i])	s.pop();
        if(s.empty())   left[i] = -1;
        else    left[i] = s.top();
        s.push(i); 
    }
    while(!s.empty()) s.pop();
    // 从右往左，找右边严格小,严格单调递减栈
    for(int i=n-1;i&gt;=0;i--){
        while(!s.empty() &amp;&amp; heights[s.top()]&gt;=heights[i])	s.pop();
        if(s.empty())   right[i] = n;
        else    right[i] = s.top();
        s.push(i); 
    }
    // 计算答案
    int maxa = 0;
    for(int i=0;i&lt;n;i++){
        maxa = max(maxa, heights[i]*(right[i]-left[i]-1));
    }
    return maxa;
}</code></pre>
</div>
</div>
</p>
<p><a href="https://leetcode.cn/problems/daily-temperatures/description">739. 每日温度 - 力扣（LeetCode）</a></p>
<p>单调栈经典例题，提醒一下：单调栈经常存储的是<strong>下标</strong>，而属性信息则使用下标查表</p>
<p>
<div class="code-container">
<div class="code-tabs">
<button class="tab-btn active" data-lang="python">Python</button>
<button class="tab-btn" data-lang="cpp">C++</button>
</div>
<div class="code-blocks">
<pre class="code-block active" data-lang="python"><code class="language-python"># 此部分代码待实现</code></pre>
<pre class="code-block" data-lang="cpp"><code class="language-cpp">vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; temperatures) {
    int n = temperatures.size();
    vector&lt;int&gt; ans(n, 0);
    stack&lt;int&gt; s; // 只存储索引，不需要结构体
    for (int i = n - 1; i &gt;= 0; i--) {
        while (!s.empty() &amp;&amp; temperatures[i] &gt;= temperatures[s.top()])	s.pop();
        if (!s.empty())	ans[i] = s.top() - i;
        s.push(i);
    }
    return ans;
}</code></pre>
</div>
</div>
</p>
<p>四道同思路的拓展题：</p>
<p><a href="https://leetcode.cn/problems/remove-k-digits/description/">402. 移掉 K 位数字 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/problems/remove-duplicate-letters/">316. 去除重复字母 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/description/">581. 最短无序连续子数组 - 力扣（LeetCode）</a></p>
<h3 id="_10">单调队列</h3>
<p><a href="https://leetcode.cn/problems/sliding-window-maximum/description">239. 滑动窗口最大值 - 力扣（LeetCode）</a></p>
<h3 id="_11">前缀和</h3>
<p><a href="https://leetcode.cn/problems/subarray-sum-equals-k/description">560. 和为 K 的子数组 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/problems/path-sum-iii/description">437. 路径总和 III - 力扣（LeetCode）</a></p>
<h2 id="_12">树</h2>
<p><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/">124. 二叉树中的最大路径和 - 力扣（LeetCode）</a></p>
<p>
<div class="code-container">
<div class="code-tabs">
<button class="tab-btn active" data-lang="python">Python</button>
<button class="tab-btn" data-lang="cpp">C++</button>
</div>
<div class="code-blocks">
<pre class="code-block active" data-lang="python"><code class="language-python">def maxsum(self, p):
    if p == None: return 0
    left = max(self.maxsum(p.left), 0)
    right = max(self.maxsum(p.right), 0)
    price = p.val + left + right
    self.maxn = max(self.maxn, price)
    return p.val + max(left, right)

def maxPathSum(self, root: Optional[TreeNode]) -&gt; int:
    # 最大和的思想往往转变为对正数的无条件合并
    self.maxn = float("-inf")
    self.maxsum(root)
    return self.maxn</code></pre>
<pre class="code-block" data-lang="cpp"><code class="language-cpp">// 此部分代码待实现</code></pre>
</div>
</div>
</p>
<h2 id="_13">动态规划</h2>
<h3 id="dp">DP 问题分类大观</h3>
<table>
<thead>
<tr>
<th>问题特征</th>
<th>可能类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>涉及数组/字符串的<strong>单个序列</strong>操作，状态与序列位置直接相关（仅依赖序列前驱）</td>
<td><strong>线性DP</strong></td>
</tr>
<tr>
<td>涉及<strong>两个序列</strong>的匹配或比较</td>
<td><strong>双序列DP</strong></td>
</tr>
<tr>
<td><strong>选择物品</strong>且有<strong>容量限制</strong>，状态定义中包含容量维度</td>
<td><strong>背包问题</strong></td>
</tr>
<tr>
<td>操作对象是<strong>区间或子序列</strong>（需枚举分割点）</td>
<td><strong>区间DP</strong></td>
</tr>
<tr>
<td>问题在<strong>树形结构</strong>上操作</td>
<td><strong>树形DP</strong></td>
</tr>
<tr>
<td>存在多个<strong>互斥状态</strong>，状态间有明确的转移规则。</td>
<td><strong>状态机DP</strong></td>
</tr>
</tbody>
</table>
<h3 id="dp_1">线性 DP</h3>
<p><strong>核心特点</strong>：状态与序列位置直接相关</p>
<p><strong>经典问题</strong>：最长递增子序列（LIS）、最大子数组和</p>
<p>🎯 <strong>状态定义套路</strong>：<code>dp[i]</code>：<strong>以第 i 个元素结尾</strong>的某种最优解</p>
<h4 id="_14">递推问题</h4>
<p><a href="https://leetcode.cn/problems/frog-jump/description/">403. 青蛙过河 - 力扣（LeetCode）</a></p>
<p><strong>问题</strong>：如果青蛙上一步跳跃了 <code>k</code> 个单位，那么它接下来的跳跃距离只能选择为 <code>k - 1</code>、<code>k</code> 或 <code>k + 1</code> 个单位。升序的 <code>stones</code> 列表指出了石头位置。</p>
<ul>
<li><strong>问题分析</strong>：</li>
<li>此处有两个需要记忆的：1、能不能跳到；2、上一步跳的距离</li>
<li>此处用倒序 <code>dp</code>是不合适的，因为现在能跳多远受到了前面的限制，而且并不是遮盖问题，是有上下界的</li>
<li>需要注意的是，石头间的距离是固定的，这意味着间隔 = 跳跃距离</li>
<li><strong>状态定义</strong>：<code>dp[i][k]</code>: 用 <code>k</code> 步跳到 <code>stones[i]</code> 的可能性</li>
<li><strong>状态转移</strong>：<code>dp[i][k] = dp[j][k] || dp[j][k+1] || dp[j][k-1], j=idx(stones[i]-k)</code></li>
<li>这里反向找索引是没必要的，因为 <code>k=stones[i]-stones[j]</code>,可以计算 k 而不是 <code>j</code> 的位置</li>
</ul>
<p>
<div class="code-container">
<div class="code-tabs">
<button class="tab-btn active" data-lang="python">Python</button>
<button class="tab-btn" data-lang="cpp">C++</button>
</div>
<div class="code-blocks">
<pre class="code-block active" data-lang="python"><code class="language-python">def canCross(self, stones: List[int]) -&gt; bool:
    if stones[1]!=1:return False
	n = len(stones)
	dp=[[False]*(n+1) for _ in range(n)]
	dp[1][1]=True
	for i in range(2, n):
    	for j in range(1, i):
        	k = stones[i]-stones[j]
        	if k&lt;n: dp[i][k] = dp[j][k] or dp[j][k+1] or dp[j][k-1]
    for i in range(len(dp[0])):
        if dp[-1][i]: return True
    return False</code></pre>
<pre class="code-block" data-lang="cpp"><code class="language-cpp">// 此部分代码待实现</code></pre>
</div>
</div>
</p>
<h4 id="_15">连续子数组问题</h4>
<p>🎯 <strong>状态定义</strong>：<code>dp[i]</code>：以第 i 个元素<strong>结尾</strong>的连续子数组问题</p>
<p><strong>状态转移</strong>：<code>dp[i]=f(nums[i], g(dp[i-1],nums[i]))</code>：要么追加，要么单开，其中 <code>f</code> 是状态选择函数，<code>g</code> 是状态计算函数</p>
<p><strong>空间优化</strong>：如果只关注前驱，只保留 <code>pre</code> 即可</p>
<p><a href="https://leetcode.cn/problems/maximum-subarray/description">53. 最大子数组和 - 力扣（LeetCode）</a></p>
<p><strong>问题</strong>：找出一个具有最大和的连续非空子数组</p>
<ul>
<li><strong>问题分析</strong>：</li>
<li>连续 -&gt; 连续子数组问题（要么追加，要么单开）</li>
<li>最大和 -&gt; 状态转移 <code>f:max</code>，<code>g:+</code></li>
<li><strong>状态定义</strong>：<code>dp[i]</code>：以第 i 个元素结尾的最大子数组和</li>
<li><strong>状态转移方程</strong>：<code>dp[i] = max(nums[i],dp[i-1]+nums[i]);</code></li>
<li><strong>最终目标</strong>：<code>max(dp)</code></li>
<li><strong>边界条件与限制</strong>：<code>dp[0] = nums[0]</code> </li>
</ul>
<p>
<div class="code-container">
<div class="code-tabs">
<button class="tab-btn active" data-lang="python">Python</button>
<button class="tab-btn" data-lang="cpp">C++</button>
</div>
<div class="code-blocks">
<pre class="code-block active" data-lang="python"><code class="language-python">def maxSubArray(self, nums: List[int]) -&gt; int:
    dp = [0]*len(nums)
    dp[0] = nums[0];
    for i in range(1, len(nums)):
        dp[i] = max(nums[i],dp[i-1]+nums[i])
    return max(dp)</code></pre>
<pre class="code-block" data-lang="cpp"><code class="language-cpp">int maxSubArray(vector&lt;int&gt;&amp; nums) {
    vector&lt;int&gt; dp(nums.size());
    dp[0] = nums[0];
    int maxn = dp[0];
    for(int i=1;i&lt;nums.size();i++){
        dp[i] = max(nums[i],dp[i-1]+nums[i]);
        if(maxn&lt;dp[i]) maxn=dp[i];
    }
    return maxn;
}</code></pre>
</div>
</div>
</p>
<ul>
<li><strong>空间优化</strong>：只关注直接前驱，考虑使用前驱变量或者直接原地修改</li>
</ul>
<p>
<div class="code-container">
<div class="code-tabs">
<button class="tab-btn active" data-lang="python">Python</button>
<button class="tab-btn" data-lang="cpp">C++</button>
</div>
<div class="code-blocks">
<pre class="code-block active" data-lang="python"><code class="language-python">def maxSubArray(self, nums: List[int]) -&gt; int:
    for i in range(1, len(nums)):
        nums[i] += max(nums[i - 1], 0)
    return max(nums)</code></pre>
<pre class="code-block" data-lang="cpp"><code class="language-cpp">int maxSubArray(vector&lt;int&gt;&amp; nums) {
    int maxn = nums[0];
    for(int i=1;i&lt;nums.size();i++){
        nums[i] += max(nums[i-1],0);
        if(maxn&lt;nums[i]) maxn=nums[i];
    }
    return maxn;
}</code></pre>
</div>
</div>
</p>
<p><a href="https://leetcode.cn/problems/maximum-product-subarray/description">152. 乘积最大子数组 - 力扣（LeetCode）</a></p>
<p><strong>问题</strong>：找出一个具有最大乘积的连续非空子数组</p>
<ul>
<li><strong>问题分析</strong>：</li>
<li>连续 -&gt; 连续子数组问题（要么追加，要么单开）</li>
<li>最大乘积 -&gt; 状态转移 <code>f:max</code>，<code>g:*</code></li>
<li>问题特性：对于乘法，负数会逆转结果，所以只维护最大值是不行的，还要考虑负半轴的最小值</li>
<li><strong>状态定义</strong>：<code>dp[i]</code>：以第 i 个元素结尾的最大子数组乘积</li>
<li><strong>状态转移方程</strong>：单开显然不用讨论，讨论追加情况，各自再加上当前数比较</li>
<li>当前元素为<strong>正</strong>数：<ul>
<li><strong>最大乘积</strong>（<code>dp[i]</code>）可能是前一个最大乘积乘以当前数</li>
<li><strong>最小乘积</strong>（<code>mindp[i]</code>）可能是前一个最小乘积乘以当前数</li>
</ul>
</li>
<li>当前元素为<strong>负</strong>数：<ul>
<li><strong>最大乘积</strong>（<code>dp[i]</code>）可能由前一个最小乘积（负数）乘以当前数（负负得正）得到</li>
<li><strong>最小乘积</strong>（<code>mindp[i]</code>）可能由前一个最大乘积（正数）乘以当前数得到</li>
</ul>
</li>
<li><strong>最终目标</strong>：<code>max(dp)</code></li>
<li><strong>边界条件与限制</strong>：<code>dp[0] = nums[0]</code> </li>
</ul>
<p>
<div class="code-container">
<div class="code-tabs">
<button class="tab-btn active" data-lang="python">Python</button>
<button class="tab-btn" data-lang="cpp">C++</button>
</div>
<div class="code-blocks">
<pre class="code-block active" data-lang="python"><code class="language-python">def maxProduct(self, nums: List[int]) -&gt; int:
    dp = [nums[0]] * len(nums)
    mindp = [nums[0]] * len(nums)
    for i in range(1,len(nums)):
        if nums[i] &gt; 0: # 正数
            mindp[i] = min(mindp[i-1]*nums[i], nums[i])
            dp[i] = max(dp[i-1]*nums[i], nums[i])
        else: # 负数
            mindp[i] = min(dp[i-1]*nums[i], nums[i])
            dp[i] = max(mindp[i-1]*nums[i], nums[i])
    return max(dp)</code></pre>
<pre class="code-block" data-lang="cpp"><code class="language-cpp">int maxProduct(vector&lt;int&gt;&amp; nums) {
    int n = nums.size();
    vector&lt;int&gt; dp(n, 0), neg(n,0);
    dp[0] = nums[0], mindp[0]=nums[0];
    int res = dp[0];
    for(int i=1;i&lt;n;i++){
        if(nums[i]&gt;0){
            neg[i] = min(mindp[i-1]*nums[i], nums[i]); // 默认neg是负数
            dp[i] = max(dp[i-1]*nums[i], nums[i]);
        }   
        else{
            neg[i] = min(dp[i-1]*nums[i], nums[i]); // 默认dp是负数
            dp[i] = max(mindp[i-1]*nums[i], nums[i]);
        }
        if(res&lt;dp[i]) res = dp[i];
    }
    return res;
}</code></pre>
</div>
</div>
</p>
<ul>
<li><strong>空间优化</strong></li>
</ul>
<p>
<div class="code-container">
<div class="code-tabs">
<button class="tab-btn active" data-lang="python">Python</button>
<button class="tab-btn" data-lang="cpp">C++</button>
</div>
<div class="code-blocks">
<pre class="code-block active" data-lang="python"><code class="language-python">def maxProduct(self, nums: List[int]) -&gt; int:
    dp = nums
    maxdp = dp[0]
    mindp = dp[0]
    for i in range(1,len(nums)):
        tempmaxdp = max(nums[i], maxdp*nums[i], mindp*nums[i])
        tempmindp = min(nums[i], mindp*nums[i], maxdp*nums[i])
        maxdp = tempmaxdp
        mindp = tempmindp
        dp[i] = max(dp[i-1], maxdp)
    return dp[-1]</code></pre>
<pre class="code-block" data-lang="cpp"><code class="language-cpp">// 此部分代码待实现</code></pre>
</div>
</div>
</p>
<p><a href="https://leetcode.cn/problems/longest-turbulent-subarray/description/">978. 最长湍流子数组 - 力扣（LeetCode）</a></p>
<p><strong>问题</strong>：找出最长的一个连续子数组，它内部的不等号在相邻的元素之间反向，输出其长度</p>
<ul>
<li><strong>问题分析</strong>：</li>
<li>连续 -&gt; 连续子数组问题（要么追加，要么单开），看到连续就想到是序列DP了</li>
<li>分析核心判断：不号反向，有两种情况：<ul>
<li><code>arr[i-2]&gt;arr[i-1] and arr[i-1]&lt;arr[i]</code></li>
<li><code>arr[i-2]&lt;arr[i-1] and arr[i-1]&gt;arr[i]</code></li>
</ul>
</li>
<li>合并一下，也就是中间元素 <code>arr[i-1]</code> 是最大值或者最小值，意味着两边元素与其做差是同号的：<code>(arr[i-2]-arr[i-1])*(arr[i]-arr[i-1])&gt;0</code></li>
<li><strong>状态定义</strong>：<code>dp[i]</code>：以第 i 个元素结尾的最长连续湍流子数组长度</li>
<li><strong>状态转移方程</strong>：<code>dp[i] = dp[i-1]+1, if (arr[i-2]-arr[i-1])*(arr[i]-arr[i-1])&gt;0</code></li>
<li><strong>最终目标</strong>：<code>max(dp)</code></li>
<li><strong>边界条件与限制</strong>：湍流子数组的基本长度分别是 1（和旁边元素相等或者没有旁边元素）；2（和旁边元素有不等关系）<code>dp[i] = 1 if arr[i]==arr[i-1] else 2</code> </li>
</ul>
<p>
<div class="code-container">
<div class="code-tabs">
<button class="tab-btn active" data-lang="python">Python</button>
<button class="tab-btn" data-lang="cpp">C++</button>
</div>
<div class="code-blocks">
<pre class="code-block active" data-lang="python"><code class="language-python">def maxTurbulenceSize(self, arr: List[int]) -&gt; int:
    n = len(arr)
    if n == 1: return 1
    dp = [1]*n
    for i in range(1, n):
         dp[i] = 1 if arr[i]==arr[i-1] else 2
    for i in range(2, n):
        if (arr[i-2]-arr[i-1])*(arr[i]-arr[i-1])&gt;0:
            dp[i] = dp[i-1]+1
    return max(dp)</code></pre>
<pre class="code-block" data-lang="cpp"><code class="language-cpp">int sign(int x){
    if(x==0) return 0;
    return x&gt;0? 1 : -1;
}
int maxTurbulenceSize(vector&lt;int&gt;&amp; arr) {
    int n = arr.size();
    if(n==1) return 1;
    vector&lt;int&gt; dp(n);
    dp[0] = 1;
    int res = arr[0]!=arr[1]? 2 : 1;
    for(int i=1;i&lt;n;i++)
        dp[i] = arr[i]==arr[i-1] ? 1 : 2;
    for(int i=2;i&lt;n;i++){
        if (sign(arr[i-2]-arr[i-1])*sign(arr[i]-arr[i-1])&gt;0)
            dp[i] = dp[i-1]+1;
        res = max(res, dp[i]);
    }
    return res;
}</code></pre>
</div>
</div>
</p>
<ul>
<li><strong>空间优化</strong>：很显然，这个问题的 <code>dp</code> 状态也只关注前驱</li>
</ul>
<p>
<div class="code-container">
<div class="code-tabs">
<button class="tab-btn active" data-lang="python">Python</button>
<button class="tab-btn" data-lang="cpp">C++</button>
</div>
<div class="code-blocks">
<pre class="code-block active" data-lang="python"><code class="language-python">def maxProduct(self, nums: List[int]) -&gt; int:
    n = len(arr)
    if n == 1: return 1
    dp = 2 if arr[0]!=arr[1] else 1
    res = dp
    for i in range(2, n):
        if (arr[i-2]-arr[i-1])*(arr[i]-arr[i-1])&gt;0:
            dp+=1
        else: dp=1 if arr[i]==arr[i-1] else 2
        res = max(res, dp)
    return res</code></pre>
<pre class="code-block" data-lang="cpp"><code class="language-cpp">int sign(int x){
    if(x==0) return 0;
    return x&gt;0? 1 : -1;
}
int maxTurbulenceSize(vector&lt;int&gt;&amp; arr) {
    int n = arr.size();
    if(n==1) return 1;
    int dp = arr[0]!=arr[1]? 2 : 1;
    int res = dp;
    for(int i=2;i&lt;n;i++){
        if (sign(arr[i-2]-arr[i-1])*sign(arr[i]-arr[i-1])&gt;0)
            dp+=1;
        else
            dp= arr[i]==arr[i-1]? 1:2;
        res = max(res,dp);
    }
    return res;
}</code></pre>
</div>
</div>
</p>
<p><a href="https://leetcode.cn/problems/decode-ways/description/">91. 解码方法 - 力扣（LeetCode）</a></p>
<p><strong>问题</strong>：计算并返回 <strong>解码</strong> 方法的 <strong>总数</strong> </p>
<ul>
<li><strong>问题分析</strong>：解码是一个顺序问题，显然是序列 DP</li>
<li><strong>状态定义</strong>：<code>dp[i]</code>：以第 i 个字符结尾的最大解码总数</li>
<li><strong>状态转移方程</strong>：解码只有两种情况：考了当前字符和考虑前两个字符</li>
<li>当前字符非 <code>0</code>：<code>dp[i-1]</code></li>
<li>前两个字符范围合法：<code>dp[i-2]</code></li>
<li>二者各自成立时候进行求和</li>
<li><strong>最终目标</strong>：<code>dp(n)</code></li>
<li><strong>边界条件与限制</strong>：<code>dp[i] = 0</code> </li>
</ul>
<p>
<div class="code-container">
<div class="code-tabs">
<button class="tab-btn active" data-lang="python">Python</button>
<button class="tab-btn" data-lang="cpp">C++</button>
</div>
<div class="code-blocks">
<pre class="code-block active" data-lang="python"><code class="language-python">def numDecodings(self, s: str) -&gt; int:
    n = len(s)
    s = " " + s
    dp = [0]*(n+1)
    dp[0] = 1
    for i in range(1,n+1):
        if '1'&lt;=s[i]&lt;='9': dp[i] = dp[i-1]
        if '10'&lt;= (s[i-1]+s[i]) &lt;='26': dp[i] += dp[i-2]
    return dp[n]</code></pre>
<pre class="code-block" data-lang="cpp"><code class="language-cpp">int numDecodings(string s) {
    int n = s.size();
    s = " " + s; // 空格哨兵，统一讨论前导0问题
    vector&lt;int&gt; dp(n + 1,0);
    dp[0] = 1;        
    for(int i = 1; i &lt; n + 1; i++) {
        int a = s[i] - '0', b = (s[i - 1] - '0') * 10 + s[i] - '0';
        if(1 &lt;= a &amp;&amp; a &lt;= 9) dp[i] = dp[i - 1];
        if(10 &lt;= b &amp;&amp; b &lt;= 26) dp[i] += dp[i - 2];
    }
    return dp[n];
}</code></pre>
</div>
</div>
</p>
<p><a href="https://leetcode.cn/problems/distinct-subsequences/description/">115. 不同的子序列 - 力扣（LeetCode）</a></p>
<h4 id="lis">最长递增子序列问题 LIS</h4>
<p><a href="https://leetcode.cn/problems/longest-increasing-subsequence/description">300. 最长递增子序列 - 力扣（LeetCode）</a></p>
<p><strong>问题</strong>：求最长递增子序列（非连续）的长度</p>
<p><strong>问题分析</strong>：作为递增问题，显然是从起点开始一路向后找的，并可以在任意处停止作为子问题，判断出是序列 DP</p>
<p>求长度最基础的暴力 DP：</p>
<ul>
<li><strong>状态定义</strong>：<code>dp[i]</code>：以 <code>nums[i]</code> 结尾的最长递增子序列长度</li>
<li><strong>状态转移</strong>：从递增关系入手：</li>
<li>找到可以和自己构成递增序列的前驱：<code>if(nums[j]&lt;nums[i]): dp[i]=dp[j]+1</code>，这一行为本身就会产生多个可能的状态</li>
<li>状态转移选择：<code>max</code></li>
</ul>
<p>
<div class="code-container">
<div class="code-tabs">
<button class="tab-btn active" data-lang="python">Python</button>
<button class="tab-btn" data-lang="cpp">C++</button>
</div>
<div class="code-blocks">
<pre class="code-block active" data-lang="python"><code class="language-python">def lengthOfLIS(nums):
    if len(nums)==1: return 1
    dp = [1] * len(nums)
    for i in range(len(nums)):
        for j in range(i):
            if nums[j] &lt; nums[i]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)</code></pre>
<pre class="code-block" data-lang="cpp"><code class="language-cpp">int lengthOfLIS(vector&lt;int&gt;&amp; nums) {
    int n = nums.size();
    if(n==1) return 1;
    int res = 0;
    vector&lt;int&gt; dp(n, 1);
    for(int i=0;i&lt;n;i++){
        for(int j=0;j&lt;i;j++){
            if(nums[j]&lt;nums[i]) 
                dp[i]=max(dp[i], dp[j]+1);
            res = max(dp[i], res);
        }
    }
    return res;
}</code></pre>
</div>
</div>
</p>
<p>上面这种基础方法太暴力太慢了，没有能够利用递增性质的全局语义（每次都从头找前驱带来了大量的浪费）</p>
<p>​   首先介绍 LIS 问题的万能建模：DAG 模型，可用于 LIS 进阶问题（图中序列是：<code>4 2 7 6 8 3 5 6</code>）</p>
<p><img alt="1" src="./figure/1.png" style="zoom:50%;"/></p>
<p>​   建模思路：</p>
<ul>
<li>数据结构：二维数组，每一层用一个列表，每个列表内部是有序的（可以视作栈）</li>
<li>构建过程：对于每个元素 <code>s[i]</code>，由于每个层的最小元素都在顶部，所以可以只看第 <code>i</code> 个栈的顶部就知道自己能不能和第 <code>i-1</code> 个栈以及之前中的元素构成递增关系，即<strong>压入到第一个栈顶比自己大的栈中</strong></li>
<li>层间联系：图上的边实际上并不需要真的存储，因为边描述的是递增关系，递增关系可以在需要的时候通过遍历查询</li>
</ul>
<p>改进模型：<strong>二分法求 LIS 长度</strong>：如果只需要求长度信息，就相当于只需要求 DAG 模型的宽度，那我们实际上就不需要保持整个 DAG 模型，而是保存它的最上层（DAG 越靠上的元素整体越小，直观上是上升速度最慢的子序列）</p>
<ul>
<li>
<p><strong>状态定义</strong>：<code>dp[i]</code>：长度为 <code>i+1</code> 的递增子序列的最末尾元素中的<strong>最小值</strong>（就是 DAG 的最上层，每一个队列我们只存储队头元素）</p>
</li>
<li>
<p><strong>状态转移</strong>：</p>
</li>
<li>
<p>遍历主数组，若当前 <code>t[i]</code> 元素大于 <code>dp[-1]</code>，则把该元素追加到 <code>dp</code> 后：<code>dp.append(t[i])</code></p>
</li>
<li>
<p>若当前 <code>t[i]</code> 元素小于 <code>dp[-1]</code>，说明找到了更慢的上升子序列，则更新 <code>dp</code>，覆盖掉 <code>dp</code> 中大于 <code>t[i]</code> 的最小元素（二分查找）</p>
</li>
<li>
<p><strong>最终目标</strong>： <code>len(dp)</code> </p>
</li>
</ul>
<p>
<div class="code-container">
<div class="code-tabs">
<button class="tab-btn active" data-lang="python">Python</button>
<button class="tab-btn" data-lang="cpp">C++</button>
</div>
<div class="code-blocks">
<pre class="code-block active" data-lang="python"><code class="language-python">def lengthOfLIS(self, nums: List[int]) -&gt; int:
    def find_upper_bound(nums, target, left, right):
        if left &gt; right:
            return left if left &lt; len(nums) else -1
        mid = (left + right) // 2
        if nums[mid] &gt;= target:
            return find_upper_bound(nums, target, left, mid - 1)
        else:
            return find_upper_bound(nums, target, mid + 1, right)
    dp = []
    dp.append(nums[0])
    for i in range(1, len(nums)):
        if nums[i]&gt;dp[-1]: dp.append(nums[i])
    	else: 
        	index = find_upper_bound(dp,nums[i],0,len(p)-1)
        	dp[index] = nums[i]
    return len(p)</code></pre>
<pre class="code-block" data-lang="cpp"><code class="language-cpp">int find_upper_bound(vector&lt;int&gt;&amp; nums, int target, int l, int r){
    if(l&gt;r)  return l&lt;nums.size() ? l : -1;
    int mid = (l+r)/2;
    if(nums[mid]&gt;=target)
        return find_upper_bound(nums, target, l, mid-1);
    else
        return find_upper_bound(nums, target, mid+1, r);
}
int lengthOfLIS(vector&lt;int&gt;&amp; nums) {
    int n = nums.size(), j =0; // j 是尾指针
    vector&lt;int&gt; dp(n, 0);
    dp[0] = nums[0];
    for(int i=0;i&lt;n;i++){
        if(nums[i]&gt;dp[j]) dp[++j]=nums[i];
        else{
            int idx = find_upper_bound(dp,nums[i],0,j);
            dp[idx]=nums[i];
        }
    }
    return j+1;
}</code></pre>
</div>
</div>
</p>
<p><strong>求最长递增子序列的个数</strong></p>
<p><a href="https://leetcode.cn/problems/number-of-longest-increasing-subsequence">673. 最长递增子序列的个数 - 力扣（LeetCode）</a></p>
<p><strong>问题分析</strong>：在 DAG 模型中，子序列个数 = 到达子序列末节点的路径个数，每次插入新元素，都需要检查前一层队列中，是自己前驱的个数和，元素构造为：<code>val, num</code></p>
<p><img alt="2" src="./figure/2.png" style="zoom:50%;"/></p>
<p>
<div class="code-container">
<div class="code-tabs">
<button class="tab-btn active" data-lang="python">Python</button>
<button class="tab-btn" data-lang="cpp">C++</button>
</div>
<div class="code-blocks">
<pre class="code-block active" data-lang="python"><code class="language-python">def findNumberOfLIS(self, nums: List[int]) -&gt; int:
    def find_lower_bound(nums, target, left, right):
        if left &gt; right:
            return left  # 返回比target小的最大元素的索引
        mid = (left + right) // 2
        if nums[mid][0] &lt; target:
            return find_lower_bound(nums, target, left, mid - 1)
        else:
            return find_lower_bound(nums, target, mid + 1, right)
    dp = [[(float('-inf'),1)]]
    for i in range(0, len(nums)):
        j = 0
        while nums[i]&gt;dp[j][-1][0]:
            j+=1
            if j==len(dp): break
        index = find_lower_bound(dp[j-1],nums[i],0,len(dp[j-1])-1)
        s_num = 0
        for idx in range(index,len(dp[j-1])):
            s_num+=dp[j-1][idx][1]
        if j==len(dp): 
            dp.append([(nums[i],s_num)])
        else: dp[j].append((nums[i],s_num))
    ans = 0
    for i in dp[-1]:
        ans+= i[1]
    return ans</code></pre>
<pre class="code-block" data-lang="cpp"><code class="language-cpp">// 此部分代码待实现</code></pre>
</div>
</div>
</p>
<p><strong>俄罗斯套娃信封问题</strong></p>
<p>​   LIS 问题的二维延伸，特点在于，你可以按照其中一个特征排序，另一个特征就会无序，随后在无序的特征维上做 LIS</p>
<p><img alt="3" src="./figure/3.png" style="zoom:50%;"/></p>
<p>​   排序中有个细节，却是点睛之笔，如果两个信封宽度相等，要按高度逆序排序 。 无论宽高，当严格大于时，才可以认为装的下。在宽相等的多个信封中，LIS 求解时只能取一个。 此时的局部逆序，则保证了 LIS 序列中最多从中取一个</p>
<p><strong>三维衍生问题</strong></p>
<p><a href="https://leetcode.cn/problems/pile-box-lcci/description/">面试题 08.13. 堆箱子 - 力扣（LeetCode）</a></p>
<p><strong>不止于不等号的 LIS</strong></p>
<p><a href="https://leetcode.cn/problems/largest-divisible-subset/description/">368. 最大整除子集 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/problems/wiggle-subsequence/description/">376. 摆动序列 - 力扣（LeetCode）</a></p>
<p>
<div class="code-container">
<div class="code-tabs">
<button class="tab-btn active" data-lang="python">Python</button>
<button class="tab-btn" data-lang="cpp">C++</button>
</div>
<div class="code-blocks">
<pre class="code-block active" data-lang="python"><code class="language-python"># 此部分代码待实现</code></pre>
<pre class="code-block" data-lang="cpp"><code class="language-cpp">int wiggleMaxLength(vector&lt;int&gt;&amp; nums) {
    int n = nums.size();
    if(n==0) return 0;
    vector&lt;int&gt; up(n,1), down(n,1);
    int res = 1;
    for(int i=1;i&lt;n;i++){
        if (nums[i] &gt; nums[i - 1]) {
            up[i]=down[i-1]+1;
            down[i]=down[i-1];
        }
        if (nums[i] &lt; nums[i - 1]){
            down[i]=up[i-1]+1;
            up[i]=up[i-1];
        } 
        if (nums[i] == nums[i - 1]){
            down[i]=down[i-1];
            up[i]=up[i-1];
        }
        res = max(res, max(up[i], down[i]));
    }
    return res;
}</code></pre>
</div>
</div>
</p>
<h4 id="_16">逆序问题</h4>
<p><strong>核心特点</strong>：状态转移方向与常规顺序相反，通常是因为当前状态的计算需要依赖后面的状态（反过来说，就是当前的决定是根据其对后续造成的影响来判断的）</p>
<p>🎯 <strong>状态定义套路</strong>：<code>dp[i]</code>：<strong>以第 i 个元素开始</strong>的某种最优解</p>
<ul>
<li>最常见的题型就是选择会造成<strong>遮盖</strong>（体现为后继的一部分数组元素可以不考虑或跳过），<code>dp</code> 状态体现为 <code>dp[i]</code> 在 <code>dp[i+1]</code> 和 <code>dp[i+k]</code> 之间做状态选择，<code>k</code> 就是被遮盖的长度</li>
<li>解题的关键就是找到被遮盖的端点 <code>i+k</code>，或者锁定遮盖长度 <code>k</code>，就能迎刃而解</li>
<li>遮盖类问题往往是无法空间优化的，因为它需要记住整个后继数组</li>
</ul>
<p><a href="https://leetcode.cn/problems/solving-questions-with-brainpower">2140. 解决智力问题 - 力扣（LeetCode）</a></p>
<p><strong>问题</strong>： 按顺序解决问题，针对每个问题选择 <strong>解决</strong> 或者 <strong>跳过</strong> 操作，每个问题有分数和屏蔽值，会屏蔽后续的 k 个问题</p>
<ul>
<li><strong>问题分析</strong>：模拟解答过程，发现是否解答这个问题取决于其屏蔽的问题价值和自身哪个大，即关注后续，倒序 DP</li>
<li><strong>状态定义</strong>：<code>dp[i]</code> 表示从第 <code>i</code> 个问题开始的最优解</li>
<li><strong>状态转移方程</strong>：</li>
<li>跳过：<code>dp[i]=dp[i+1]</code></li>
<li>不跳过，其后续 k 个问题会被屏蔽，故看 <code>dp[i+k+1]</code>：<code>dp[i] = dp[i+k+1]+p[i]</code></li>
<li>
<p>最后目标是求 <code>max</code></p>
</li>
<li>
<p><strong>最终目标</strong>：<code>dp0]</code></p>
</li>
<li><strong>边界条件与限制</strong>：跳过头的问题都需要额外处理，使用末尾的零哨兵算法会更会简洁</li>
</ul>
<p>
<div class="code-container">
<div class="code-tabs">
<button class="tab-btn active" data-lang="python">Python</button>
<button class="tab-btn" data-lang="cpp">C++</button>
</div>
<div class="code-blocks">
<pre class="code-block active" data-lang="python"><code class="language-python">def mostPoints(self, questions: List[List[int]]) -&gt; int:
    n = len(questions)
    dp=[0]*(n+1) # 最后一个作为0哨兵
    for i in range(n-1,-1,-1):
        dp[i] = max(dp[i+1],questions[i][0]+dp[min(n,i+questions[i][1]+1)])
    return dp[0]</code></pre>
<pre class="code-block" data-lang="cpp"><code class="language-cpp">long long mostPoints(vector&lt;vector&lt;int&gt;&gt;&amp; questions) {
    int n = questions.size();
    vector&lt;long long&gt; dp(n+1, 0); // 最后一个作为0哨兵
    for(int i=n-1;i&gt;=0;i--){
        dp[i]=max(dp[i+1], dp[min(n, i + questions[i][1] + 1)]+questions[i][0]);
    }
    return dp[0];
}</code></pre>
</div>
</div>
</p>
<p><a href="https://leetcode.cn/problems/minimum-cost-for-tickets/description/">983. 最低票价 - 力扣（LeetCode）</a></p>
<p><strong>问题</strong>：有三种票，各自能管 1、7、30 天，有不同的票价，给定递增的日程表，要求计算最低覆盖开销</p>
<ul>
<li><strong>问题分析</strong>：票的时间就是遮盖长度，看到遮盖问题就想到是逆序 DP；<code>days</code> 数组的递增性体现我们可以通过二分法找到屏蔽的位置，这道题和解决智力问题的区别在于：智力问题找到屏蔽端点是靠数组的索引，而本题是靠元素的值，这个映射就需要用到搜索</li>
<li><strong>状态定义</strong>：<code>dp[i]</code>表示前从 <code>days[i]</code> 开始规划的最低开销</li>
<li><strong>状态转移方程</strong>：显然，状态选择使用 <code>min</code>，有三种状态情况：</li>
<li>单买一天的：<code>dp[i+1]+costs[0]</code></li>
<li>买 7 天的：<code>dp[x]+costs[1]</code>，其中 <code>x</code> 是 <code>days[i]+7</code> 所在的索引</li>
<li>
<p>买 30 天的：<code>dp[y]+costs[1]</code>，其中 <code>y</code> 是 <code>days[i]+30</code> 所在的索引</p>
</li>
<li>
<p><strong>最终目标</strong>：<code>dp[0]</code></p>
</li>
<li><strong>边界条件与限制</strong>：<code>dp[n]=0</code> 额外处理越界的情况；<code>dp[n-1]=costs[0]</code></li>
</ul>
<p>
<div class="code-container">
<div class="code-tabs">
<button class="tab-btn active" data-lang="python">Python</button>
<button class="tab-btn" data-lang="cpp">C++</button>
</div>
<div class="code-blocks">
<pre class="code-block active" data-lang="python"><code class="language-python">def find_left(self, days, target, left, right):
    if left&gt;right: return left
	mid = (left+right)//2
	if days[mid]&gt;=target:
	    return self.find_left(days, target, left, mid-1)
    else:
		return self.find_left(days, target, mid+1, right)

def mincostTickets(self, days: List[int], costs: List[int]) -&gt; int:
    least_cost = min(costs)
    n = len(days)
    dp = [0]*(n+1)
    dp[n-1] = least_cost
    last_day = days[n-1]
    for i in range(n-2,-1,-1):
        x = n if days[i]+7&gt;last_day else self.find_left(days,days[i]+7,0,n-1)
        y = n if days[i]+30&gt;last_day else self.find_left(days,days[i]+30,0,n-1)
        dp[i]=min(dp[i+1]+costs[0], dp[x]+costs[1], dp[y]+costs[2])
    return dp[0]</code></pre>
<pre class="code-block" data-lang="cpp"><code class="language-cpp">int find_left(vector&lt;int&gt;&amp; days, int target, int left, int right){
    if(left&gt;right) return left;
    int mid = (left+right)/2;
    if(days[mid]&gt;=target)
        return find_left(days, target, left, mid-1);
    else
        return find_left(days, target, mid+1, right);
}
int mincostTickets(vector&lt;int&gt;&amp; days, vector&lt;int&gt;&amp; costs) {
    int least_cost = min(costs[0], min(costs[1], costs[2]));
    int n = days.size();
    vector&lt;int&gt; dp(n+1);
    dp[n] = 0;
    dp[n-1] = least_cost;
    int last_day = days[n-1];
    for(int i=n-2;i&gt;=0;i--){
        int x = days[i]+7&gt;last_day ? n : find_left(days,days[i]+7,0,n-1);
        int y = days[i]+30&gt;last_day ? n : find_left(days,days[i]+30,0,n-1);
        dp[i]=min(dp[i+1]+costs[0], min(dp[x]+costs[1], dp[y]+costs[2]));
    }
    return dp[0];
}</code></pre>
</div>
</div>
</p>
<p><a href="https://leetcode.cn/problems/dungeon-game/description/">174. 地下城游戏 - 力扣（LeetCode）</a></p>
<p><strong>问题</strong>：只 <strong>向右</strong> 或 <strong>向下</strong> 移动一步，点数不能降至 0 或以下，从左上角走到右下角</p>
<ul>
<li><strong>问题分析</strong>：目标状态是固定的，且从左上角开始和从任意点开始没有本质区别（子问题结构），我们尝试模拟问题求解，发现当前格中需要有的血量是从终点开始向前推导的（逆序 DP）</li>
<li><strong>状态定义</strong>：<code>dp[i][j]</code> 表示前从 <code>[i,j]</code>出发到终点所需要的最少血量</li>
<li><strong>状态转移方程</strong>：无论格子中的点数的正负，顺着走永远都是求 <code>+</code>，反过来就是求 <code>-</code></li>
<li>如果求 <code>-</code> 后大于 0：说明骑士按最低标准不会死亡，可行</li>
<li>
<p>否则：说明骑士按最低标准无法存活，则至少为 1</p>
</li>
<li>
<p><strong>最终目标</strong>：<code>dp[0][0]</code></p>
</li>
<li><strong>边界条件与限制</strong>：终点要是 1，两边单向处理</li>
</ul>
<p>
<div class="code-container">
<div class="code-tabs">
<button class="tab-btn active" data-lang="python">Python</button>
<button class="tab-btn" data-lang="cpp">C++</button>
</div>
<div class="code-blocks">
<pre class="code-block active" data-lang="python"><code class="language-python">def calculateMinimumHP(self, dungeon: List[List[int]]) -&gt; int:
    n = len(dungeon)
    m = len(dungeon[0])
    dp = [[0]*m for _ in range(n)]
    dp[n-1][m-1] = 1-dungeon[n-1][m-1] if dungeon[n-1][m-1]&lt;=0 else 1
    for i in range(n-2,-1,-1):
        dp[i][m-1] = max(dp[i+1][m-1]-dungeon[i][m-1], 1)
    for j in range(m-2,-1,-1):
        dp[n-1][j] = max(dp[n-1][j+1]-dungeon[n-1][j], 1)

    for i in range(n-2,-1,-1):
        for j in range(m-2,-1,-1):
            dp[i][j] = min(max(dp[i+1][j]-dungeon[i][j], 1),
                           max(dp[i][j+1]-dungeon[i][j], 1))
    return dp[0][0]</code></pre>
<pre class="code-block" data-lang="cpp"><code class="language-cpp">int calculateMinimumHP(vector&lt;vector&lt;int&gt;&gt;&amp; dungeon) {
    int n = dungeon.size(), m = dungeon[0].size();
    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(m,0));
    dp[n-1][m-1] = dungeon[n-1][m-1]&lt;=0? 1-dungeon[n-1][m-1]:1;
    for(int i=n-2;i&gt;=0;i--) 
        dp[i][m-1] = max(dp[i+1][m-1]-dungeon[i][m-1], 1);
    for(int j=m-2;j&gt;=0;j--) 
        dp[n-1][j] = max(dp[n-1][j+1]-dungeon[n-1][j], 1);

    for(int i=n-2;i&gt;=0;i--){
        for(int j=m-2;j&gt;=0;j--){
            dp[i][j] = min(max(dp[i+1][j]-dungeon[i][j], 1),
                           max(dp[i][j+1]-dungeon[i][j], 1));
        }
    }
    return dp[0][0];
}</code></pre>
</div>
</div>
</p>
<h4 id="_17">双序列问题</h4>
<p><strong>核心特点</strong>：</p>
<ul>
<li>操作对象是<strong>两个序列</strong>（如字符串、数组）</li>
<li>通常涉及<strong>匹配、对比、转换</strong>操作（如最长公共子序列、编辑距离）</li>
</ul>
<p><strong>经典问题</strong>：最长公共子序列、编辑距离</p>
<p>🎯 <strong>状态定义套路</strong>：</p>
<ul>
<li><code>dp[i][j]</code>：表示处理到<strong>第一个序列的第 i 个元素</strong>和<strong>第二个序列的第 j 个元素</strong>时的最优解</li>
</ul>
<p>常用技巧：<strong>双序列表格法</strong>＋字符串填充前导 0 或前导空字符，便于边界处理</p>
<p><a href="https://leetcode.cn/problems/edit-distance/description/">72. 编辑距离 - 力扣（LeetCode）</a></p>
<p><strong>问题</strong>：给你两个单词 <code>word1</code> 和 <code>word2</code>， 请返回将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数（插入，删除，替换）</p>
<p><img alt="5" src="./figure/5.png" style="zoom:65%;"/></p>
<p>
<div class="code-container">
<div class="code-tabs">
<button class="tab-btn active" data-lang="python">Python</button>
<button class="tab-btn" data-lang="cpp">C++</button>
</div>
<div class="code-blocks">
<pre class="code-block active" data-lang="python"><code class="language-python">def minDistance(self, word1: str, word2: str) -&gt; int:
    if word2=="":   return len(word1)
    if word1=="":   return len(word2)
    dp = [[0 for j in range(len(word2)+1)] for i in range(len(word1)+1)]
    # 边界
    for i in range(1,len(word1)+1): dp[i][0] = dp[i-1][0]+1
    for j in range(1,len(word2)+1): dp[0][j] = dp[0][j-1]+1

    for i in range(1,len(word1)+1):
        for j in range(1,len(word2)+1):
            if word1[i-1]==word2[j-1]: dp[i][j]=dp[i-1][j-1]
        else: dp[i][j]=min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1

    return dp[-1][-1]</code></pre>
<pre class="code-block" data-lang="cpp"><code class="language-cpp">int minDistance(string word1, string word2) {
    int n = word1.size(), m = word2.size();
    if(n==0 || m==0) return max(n,m);
    vector&lt;vector&lt;int&gt;&gt; dp(n+1,vector&lt;int&gt;(m+1,0));
    // dp[i][j] = dp[i-1][j-1], w[i]==w[j], 不编辑
    // dp[i][j] = min(dp[i-1][j],dp[i][j-1])+1 编辑
    // 边界
    for(int i=0;i&lt;n+1;i++) dp[i][0] = i;
    for(int j=0;j&lt;m+1;j++) dp[0][j] = j;

    for(int i=1;i&lt;n+1;i++){
        for(int j=1;j&lt;m+1;j++){
            if(word1[i-1]==word2[j-1])  dp[i][j] = dp[i-1][j-1];
            else dp[i][j] = min(min(dp[i-1][j],dp[i][j-1]),dp[i-1][j-1])+1;
        }
    }
    return dp[n][m];
}</code></pre>
</div>
</div>
</p>
<p><a href="https://leetcode.cn/problems/interleaving-string/?envType=study-plan-v2&amp;envId=top-interview-150">97. 交错字符串 - 力扣（LeetCode）</a></p>
<p><img alt="4" src="./figure/4.png" style="zoom:35%;"/></p>
<p><a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/description/">718. 最长重复子数组 - 力扣（LeetCode）</a></p>
<p><strong>问题</strong>：给两个整数数组 <code>nums1</code> 和 <code>nums2</code> ，返回 两个数组中公共的 、长度最长的连续子数组的长度。</p>
<ul>
<li><strong>问题分析</strong>：题目明确指明了是双序列问题，双序列 DP 启动；由连续子数问题做推广，知道我们应该以“以...结尾” 作为状态定义</li>
<li><strong>状态定义</strong>：<code>dp[i][j]</code>：以 <code>nums1[i]=nums[j]</code> 结尾的最长公共连续子数组长度</li>
<li><strong>状态转移</strong>：和其余连续子数组问题一样，要么追加要么单开，追加的条件是两个新考虑的元素相等</li>
<li><code>if nums1[i]==nums2[j]</code>：<code>dp[i][j] = dp[i-1][j-1] + 1</code>（追加）</li>
<li><code>else</code>：<code>dp[i][j] = 1</code>（单开）</li>
<li><strong>最终目标</strong>：<code>max(dp)</code></li>
<li><strong>边界条件与限制</strong>：<code>dp[i][0]=if nums1[i]==nums2[0]</code>，<code>dp[0][j]=if nums1[0]==nums2[j]</code></li>
</ul>
<p>
<div class="code-container">
<div class="code-tabs">
<button class="tab-btn active" data-lang="python">Python</button>
<button class="tab-btn" data-lang="cpp">C++</button>
</div>
<div class="code-blocks">
<pre class="code-block active" data-lang="python"><code class="language-python">def findLength(self, nums1: List[int], nums2: List[int]) -&gt; int:
    n = len(nums1)
    m = len(nums2)
    dp = [[0]*m for _ in range(n)]
    res = 0
    for i in range(n):
        for j in range(m):
            if nums1[i]==nums2[j]:
                if (i == 0 or j == 0): dp[i][j] = 1
            	else: dp[i][j] = dp[i-1][j-1] + 1
            res = max(res, dp[i][j])
    return res</code></pre>
<pre class="code-block" data-lang="cpp"><code class="language-cpp">int findLength(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {
    int n = nums1.size(), m=nums2.size();
    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(m, 0));
    int res = 0;
    for(int i=0;i&lt;n;i++)
        for(int j=0;j&lt;m;j++){
            if(nums1[i]==nums2[j]) {
                if (i == 0 || j == 0) dp[i][j] = 1; 
                else dp[i][j] = dp[i-1][j-1] + 1;
            }
            res = max(res, dp[i][j]);
        }
    return res;
}</code></pre>
</div>
</div>
</p>
<ul>
<li><strong>空间优化</strong>：注意到 <code>dp</code> 状态只依赖上一行，是很经典的二维滚动优化</li>
</ul>
<p>
<div class="code-container">
<div class="code-tabs">
<button class="tab-btn active" data-lang="python">Python</button>
<button class="tab-btn" data-lang="cpp">C++</button>
</div>
<div class="code-blocks">
<pre class="code-block active" data-lang="python"><code class="language-python">def findLength(self, nums1: List[int], nums2: List[int]) -&gt; int:
    n = len(nums1)
    m = len(nums2)
    dp = [0]*m
    res = 0
    for i in range(n):
        for j in range(m-1,-1,-1):
            if nums1[i]==nums2[j]:
                if (i == 0 or j == 0): dp[j] = 1
                else: dp[j] = dp[j-1] + 1
            else: dp[j]=0
            res = max(res, dp[j])
    return res</code></pre>
<pre class="code-block" data-lang="cpp"><code class="language-cpp">int findLength(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {
    int n = nums1.size(), m=nums2.size();
    vector&lt;int&gt; dp(m, 0);
    int res = 0;
    for(int i=0;i&lt;n;i++)
        for(int j=m-1;j&gt;=0;j--){
            if(nums1[i]==nums2[j]) {
                if (i == 0 || j == 0) dp[j] = 1; 
                else dp[j] = dp[j-1] + 1;
            }
            else dp[j]=0;
            res = max(res, dp[j]);
        }
    return res;
}</code></pre>
</div>
</div>
</p>
<p><a href="https://leetcode.cn/problems/uncrossed-lines">1035. 不相交的线 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/problems/longest-common-subsequence">1143. 最长公共子序列 - 力扣（LeetCode）</a></p>
<h4 id="_18">二维线性问题</h4>
<p><strong>核心特点</strong>：</p>
<ul>
<li>问题场景在<strong>二维网格</strong>中（如矩阵、棋盘）</li>
<li>移动方向受限（通常只能向右/向下）</li>
</ul>
<p><strong>状态定义套路</strong>：</p>
<ul>
<li><strong><code>dp[i][j]</code></strong>: 表示到达网格位置<code>(i,j)</code>时的最优解（如路径数、最小代价）</li>
</ul>
<h3 id="dp_2">区间DP：子区间最优解</h3>
<p><strong>核心特点</strong>：操作对象是区间，最外层循环是子区间长度，下一层循环是子区间起点</p>
<p><strong>经典问题</strong>：矩阵连乘、回文子串、戳气球</p>
<p>🎯 <strong>状态定义套路</strong>：<code>dp[i][j]</code>：区间 <code>[i,j]</code> 上的最优解</p>
<p>🎯 <strong>状态转移套路</strong>：<code>dp[i,j] = max/min{dp[i,j], dp[i, k] + dp[k+1, j] + cost}</code></p>
<h4 id="_19">回文串类型</h4>
<p><a href="https://leetcode.cn/problems/longest-palindromic-substring/">5. 最长回文子串 - 力扣（LeetCode）</a></p>
<p>
<div class="code-container">
<div class="code-tabs">
<button class="tab-btn active" data-lang="python">Python</button>
<button class="tab-btn" data-lang="cpp">C++</button>
</div>
<div class="code-blocks">
<pre class="code-block active" data-lang="python"><code class="language-python"># 此部分代码待实现</code></pre>
<pre class="code-block" data-lang="cpp"><code class="language-cpp">string longestPalindrome(string s) {
    // dp[i][j]: s[i..j] 是回文串
    // dp[i][j] = dp[i+1][j-1], s[i]==s[j]
    int n = s.size();
    vector&lt;vector&lt;bool&gt;&gt; dp(n, vector&lt;bool&gt;(n, false));
    int resi=0, reslen=1;
    for(int i=0;i&lt;n;i++) dp[i][i]=true;
    for(int len=2;len&lt;=n;len++){
        for(int i=0;i&lt;=n-len;i++){
            int j = i+len-1;
            if(s[i]==s[j]){
                if(i==j-1)  dp[i][j]=true; //len=2的情况
                else dp[i][j] = dp[i+1][j-1];
            }  
            if(dp[i][j] &amp;&amp; j-i+1&gt;reslen){
                reslen = j-i+1;
                resi = i;
            }
        }
    }
    return s.substr(resi, reslen);
}</code></pre>
</div>
</div>
</p>
<p><a href="https://leetcode.cn/problems/shortest-palindrome/description/">214. 最短回文串 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/problems/longest-palindromic-subsequence/description/">516. 最长回文子序列 - 力扣（LeetCode）</a></p>
<p>
<div class="code-container">
<div class="code-tabs">
<button class="tab-btn active" data-lang="python">Python</button>
<button class="tab-btn" data-lang="cpp">C++</button>
</div>
<div class="code-blocks">
<pre class="code-block active" data-lang="python"><code class="language-python"># 此部分代码待实现</code></pre>
<pre class="code-block" data-lang="cpp"><code class="language-cpp">int longestPalindromeSubseq(string s) {
    int n = s.size();
    vector&lt;vector&lt;int&gt;&gt; dp(n,vector&lt;int&gt;(n,0));
    for(int i=0;i&lt;n;i++) dp[i][i]=1;
    for(int len=2;len&lt;=n;len++){
        for(int i=0;i&lt;=n-len;i++){
            int j = i+len-1;
            if(s[i]==s[j])  dp[i][j]=dp[i+1][j-1]+2;
            else    dp[i][j]=max(dp[i][j-1],dp[i+1][j]);
        }
    }
    return dp[0][n-1];
}</code></pre>
</div>
</div>
</p>
<p><a href="https://leetcode.cn/problems/minimum-insertion-steps-to-make-a-string-palindrome/description/">1312. 让字符串成为回文串的最少插入次数 - 力扣（LeetCode）</a></p>
<p>
<div class="code-container">
<div class="code-tabs">
<button class="tab-btn active" data-lang="python">Python</button>
<button class="tab-btn" data-lang="cpp">C++</button>
</div>
<div class="code-blocks">
<pre class="code-block active" data-lang="python"><code class="language-python"># 此部分代码待实现</code></pre>
<pre class="code-block" data-lang="cpp"><code class="language-cpp">int minInsertions(string s) {
    int n = s.size();
    vector&lt;vector&lt;int&gt;&gt; dp(n,vector&lt;int&gt;(n,0));
    for(int len=2;len&lt;=n;len++){
        for(int i=0;i&lt;=n-len;i++){
            int j = i+len-1;
            if(s[i]==s[j])  dp[i][j]=dp[i+1][j-1];
            else    dp[i][j]=min(dp[i][j-1],dp[i+1][j])+1;
        }
    }
    return dp[0][n-1];
}</code></pre>
</div>
</div>
</p>
<p><a href="https://leetcode.cn/problems/palindrome-partitioning-ii/description/">132. 分割回文串 II - 力扣（LeetCode）</a></p>
<h4 id="_20">分割点类型</h4>
<p><strong>矩阵连乘（LeetCode 没有）</strong></p>
<p><strong>问题</strong>：给定一系列矩阵 $A_1,A_2,…,A_n$，其中矩阵 $A_i$ 的维度为 $p_{i-1}\times p_i$。寻找最优的矩阵乘法顺序，使得总计算量（乘法次数）最小。</p>
<ul>
<li><strong>问题分析</strong>：需要使用结合率减小运算复杂度，这是因为不同运算顺序，中间的运算维度大小不一样</li>
<li><strong>状态定义</strong>：<code>dp[i][j]</code>：<code>A_i,...,A_j</code> 所需的最小乘法次数</li>
<li><strong>状态转移</strong>：对于一串矩阵中的一个分割点 <code>k</code> 来说：</li>
<li>其左右两侧的乘法次数为：$dp[i][k]+dp[k+1][j]$</li>
<li>其本身与两侧矩阵的乘法次数为：$p_{i-1}\times p_k\times p_j$</li>
<li>状态选择函数为：<code>min</code></li>
<li><strong>最终目标</strong>：<code>dp[1][n]</code></li>
<li><strong>边界条件与限制</strong>：<code>dp[i][i]=0</code>，单个矩阵无需计算</li>
</ul>
<p>
<div class="code-container">
<div class="code-tabs">
<button class="tab-btn active" data-lang="python">Python</button>
<button class="tab-btn" data-lang="cpp">C++</button>
</div>
<div class="code-blocks">
<pre class="code-block active" data-lang="python"><code class="language-python">def matrix_chain_order(p):
    n = len(p) - 1  # 矩阵个数
    dp = [[0] * (n + 1) for _ in range(n + 1)]
    
    for l in range(2, n + 1):  # 子链长度
        for i in range(1, n - l + 2):
            j = i + l - 1
            dp[i][j] = float('inf')
            for k in range(i, j):
                cost = dp[i][k] + dp[k+1][j] + p[i-1]*p[k]*p[j]
                if cost &lt; dp[i][j]:
                    dp[i][j] = cost
    return dp[1][n]</code></pre>
<pre class="code-block" data-lang="cpp"><code class="language-cpp">int matrixChainOrder(vector&lt;int&gt;&amp; p) {
    int n = p.size() - 1;
    vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(n + 1, 0));
    
    for (int l = 2; l &lt;= n; ++l) { // 子链长度
        for (int i = 1; i &lt;= n - l + 1; ++i) {
            int j = i + l - 1;
            dp[i][j] = INT_MAX;
            for (int k = i; k &lt; j; ++k) {
                int cost = dp[i][k] + dp[k+1][j] + p[i-1] * p[k] * p[j];
                if (cost &lt; dp[i][j]) {
                    dp[i][j] = cost;
                }
            }
        }
    }
    return dp[1][n];
}</code></pre>
</div>
</div>
</p>
<p><a href="https://leetcode.cn/problems/burst-balloons/description/">312. 戳气球 - 力扣（LeetCode）</a></p>
<p>
<div class="code-container">
<div class="code-tabs">
<button class="tab-btn active" data-lang="python">Python</button>
<button class="tab-btn" data-lang="cpp">C++</button>
</div>
<div class="code-blocks">
<pre class="code-block active" data-lang="python"><code class="language-python"># 此部分代码待实现</code></pre>
<pre class="code-block" data-lang="cpp"><code class="language-cpp">int maxCoins(vector&lt;int&gt;&amp; nums) {
    // 我也不知道为什么是区间dp
    // dp[i][j]: 考虑开子区间的最优解
    // dp[i][k]: k 是最后一个戳爆的气球
    nums.insert(nums.begin(),1);
    nums.push_back(1);
    int n = nums.size();
    vector&lt;vector&lt;int&gt;&gt; dp(n+1, vector&lt;int&gt;(n+1, 0));
    for(int len=2;len&lt;n;len++) // 区间dp特点：最外层是区间长度
        for(int i=0;i&lt;n-len;i++)
            for(int k=i+1;k&lt;i+len;k++)
                dp[i][i+len] = max(dp[i][i+len], dp[i][k]+nums[i]*nums[k]*nums[i+len]+dp[k][i+len]);

    return dp[0][n-1];
}</code></pre>
</div>
</div>
</p>
<p><a href="https://leetcode.cn/problems/scramble-string/">87. 扰乱字符串 - 力扣（LeetCode）</a></p>
<p><strong>问题</strong>：如果一个字符串 <code>s1</code> 被划分为 <code>s1=x+y</code>，则可以选择是否交换而得到一个扰乱后的字符串 <code>s2</code>，继续再两个子串上执行这个算法，最终得到一个扰乱字符串。问给定的字符串 <code>s2</code> 是否是 <code>s1</code> 的扰乱字符串</p>
<ul>
<li><strong>问题分析</strong>：题目中显式地提到了划分点，区间 DP，启动。首先这个扰乱算法是可逆的，我们将这个逆操作设为 <code>f</code>，我们实际上要判断是否存在这样一种划分方式：使得 <code>s1</code> 划分出 <code>x1</code> 和 <code>y1</code>， <code>s2</code> 划分出 <code>x2</code> 和 <code>y2</code>，且 <code>f(x2)=x1,f(y2)=y1</code>，或者 <code>f(x2)=y1,f(y2)=x1</code>，则 <code>f(s2)=s1</code>。本题是<strong>双区间划分</strong>问题，但是有长度一样这个对齐标准，所以可以用三维数组记录状态</li>
<li><strong>状态定义</strong>：<code>dp[i][j][k]</code>：<code>s2[j:j+k]</code> 是不是 <code>s1[i,i+k]</code> 的扰乱字符串</li>
<li><strong>状态转移</strong>：设划分点到 <code>i</code> 的距离为 <code>d</code>，从满足扰乱匹配要求的两种情况出发：</li>
<li><code>dp[i][j][d]</code>（<code>f(x2)=x1</code>） <code>and</code> <code>dp[i+d][j+d][k-d]</code>（<code>f(y2)=y1</code>）</li>
<li><code>dp[i][j+k-d][d]</code>（<code>f(x2)=y1</code>）<code>and</code> <code>dp[i+d][j][k-d]</code>（<code>f(y2)=x1</code>）</li>
<li>两种情况只需要一个满足，所以状态选择函数为 <code>or</code>，另外只需要找到一个划分满足即可，因此找到了就跳出切点的循环</li>
<li><strong>最终目标</strong>：<code>dp[0][0][n]</code></li>
<li><strong>边界条件与限制</strong>：</li>
<li><code>len(s1) == len(s2)</code>：必要条件，长度得一样</li>
<li><code>dp[i][j][1]==True if s1[i]==s2[j] else False</code>：边界条件，单字符匹配</li>
</ul>
<p>
<div class="code-container">
<div class="code-tabs">
<button class="tab-btn active" data-lang="python">Python</button>
<button class="tab-btn" data-lang="cpp">C++</button>
</div>
<div class="code-blocks">
<pre class="code-block active" data-lang="python"><code class="language-python">def isScramble(self, s1: str, s2: str) -&gt; bool:
        # 题目中显式地提到了划分点，区间 DP，启动
        # dp[i][j][k]: s2[j:j+k] 是不是 s1[i,i+k] 的扰乱字符串，划分点位于i,i+k之间
        # 划分点相对于i的距离与相对于j或者j+k的距离是一样的
        # 划分只有两种情况，设划分点到 i 的距离为 d
        # 1.s1[i,i+d]==s2[j,j+d] and s1[i+d,i+k]==s2[j+d,j+k]
        # 2.s1[i,i+d]==s2[j+k-d,j+k] and s1[i+d,i+k]==s2[j,j+k-d]
        # 只有以上情况满足一个，才能认定为是扰乱字符串
        # 子问题性质：如果两个子串已经被确定是互为扰乱的，则我们可以把它们看成相同的字符串
        # 这意味着，在这个问题中，两个字串是互为扰乱的，和两个字串相同是一回事(dp==True)
        # 所以说，我们就不需要使用 == 来判断，而是使用dp的记忆
        # dp[i][j][k] = (dp[i][j][d] and dp[i+d][j+d][k-d]) or (dp[i][j+k-d][d] and dp[i+d][j][k-d])
        # 边界: dp[i][j][1]=True if s1[i]==s2[j] else False
        if len(s1) != len(s2): return False
        n = len(s1)
        dp=[[[False]*(n+1) for j in range(n)] for i in range(n)]
        for i in range(n):
            for j in range(n):
                if s1[i]==s2[j]: dp[i][j][1] = True
        for k in range(1, n+1):
            for i in range(n-k+1):
                for j in range(n-k+1):
                    for d in range(1,k):
                        dp[i][j][k] = (dp[i][j][d] and dp[i+d][j+d][k-d]) or (dp[i][j+k-d][d] and dp[i+d][j][k-d])
                        if dp[i][j][k]: break
        return dp[0][0][n]</code></pre>
<pre class="code-block" data-lang="cpp"><code class="language-cpp">// 此部分代码待实现</code></pre>
</div>
</div>
</p>
<p><a href="https://leetcode.cn/problems/minimum-cost-to-merge-stones/description/">1000. 合并石头的最低成本 - 力扣（LeetCode）</a></p>
<p>
<div class="code-container">
<div class="code-tabs">
<button class="tab-btn active" data-lang="python">Python</button>
<button class="tab-btn" data-lang="cpp">C++</button>
</div>
<div class="code-blocks">
<pre class="code-block active" data-lang="python"><code class="language-python"># 此部分代码待实现</code></pre>
<pre class="code-block" data-lang="cpp"><code class="language-cpp">int mergeStones(vector&lt;int&gt;&amp; stones, int k) {
    // 区间dp
    int n = stones.size();
    if((n-1)%(k-1)!=0) return -1;

    vector&lt;int&gt; prefix(n+1,0);// 计算前缀和，便于计算代价
    for(int i=0;i&lt;n;i++)    prefix[i + 1] = prefix[i] + stones[i];

    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n,99999));
    for(int i=0;i&lt;n;i++) dp[i][i] = 0;

    for(int len=2;len&lt;=n;len++){
        for(int i=0;i&lt;=n-len;i++){
            int j = i+len-1;
            for(int p=i;p&lt;j;p+=k-1)    // 尝试所有可能的分割点
                dp[i][j] = min(dp[i][j], dp[i][p] + dp[p+1][j]);
            // 如果当前区间长度满足可以合并成一堆的条件，加上合并的成本
            if ((j - i) % (k - 1) == 0)
                dp[i][j] += prefix[j + 1] - prefix[i];
        }
    }
    return dp[0][n-1];
}</code></pre>
</div>
</div>
</p>
<h3 id="_21">背包问题：选择与容量</h3>
<p><strong>核心特点</strong>：物品选择 + 容量限制（在有约束的情况下，对某个元素<strong>要么拿要么不拿</strong>）</p>
<p><strong>经典问题</strong>：01背包、完全背包、分割等和子集</p>
<p>🎯 <strong>状态定义套路</strong>：<code>dp[i][w]</code>：前 i 个物品，容量为 w 时的最优解（实际定义数组需要以 n+1 和 w+1 为尺寸）</p>
<p>🎯 <strong>状态转移套路</strong>：背包问题特点：最外层循环是背包容量，下一层循环是物品</p>
<p><strong>空间优化</strong>：</p>
<ul>
<li>常用一维数组<code>dp[w]</code>：发现<code>dp[i][w]</code>的计算仅依赖上一行<code>dp[i-1][...]</code>的值，因此可以用一维数组滚动更新，<strong>覆盖旧状态</strong>。（01背包覆盖通常需要<strong>从右向左更新</strong>，反向遍历；而完全背包正向遍历）</li>
<li>优化前，<code>i</code> 的遍历范围是<code>[1,n]</code>，<code>dp</code> 数组的尺寸是 <code>[n+1][p+1]</code>；优化后 <code>i</code> 的遍历范围是 <code>[0,n-1]</code>，<code>dp</code> 数组的尺寸是 <code>[p+1]</code></li>
<li>优化前，需要判断背包余量和物品重量的关系（二维表格全遍历，存在物品重量大于余量的情况，需要复制之前的结果）；而优化后不需要（只遍历物品重量到余量，自动跳过无法取的情况，之前的结果只是不被覆盖，不需要显式复制），实际上空间优化的同时也优化了时间开销（复杂度相同）</li>
</ul>
<h4 id="0-1">0-1 背包</h4>
<p><strong>核心特点</strong>：有 n 种物品，每种物品只有一个，每个物品有自己的重量和价值</p>
<p><strong>关键难点</strong>：难点在于问题转化，不会那么直白得提问，需要化归</p>
<p>🎯 <strong>状态转移套路</strong>：<code>dp[i][j]=f(dp[i-1][j], dp[i-1][j-w[i]]+v[i])</code>，01 背包由于 ”只能拿一次” 的特点，其前驱状态都需要从 <code>dp[i-1][...]</code> 中进行转移，而不会考虑相同 <code>i</code> 的其它状态</p>
<ul>
<li>拿不下就不拿：<code>if(j&lt;w[i]) dp[i][j]=dp[i-1][j]</code></li>
<li>拿得下再决定：<code>else dp[i][j]=f(dp[i-1][j], dp[i-1][j-w[i]]+v[i])</code>，其中 <code>f</code> 是转移函数，用于衡量拿和不拿哪一个状态对目标有利，常见有：<code>max</code>，<code>min</code>，<code>||</code>，<code>+</code></li>
<li>求值：<code>dp[i][j]=max(dp[i-1][j],dp[i-1][j-w[i]]+v[i])</code></li>
</ul>
<p><a href="https://leetcode.cn/problems/partition-equal-subset-sum/description">416. 分割等和子集 - 力扣（LeetCode）</a></p>
<p><strong>问题</strong>：能否将数组分割成两个和相等的子集？</p>
<ul>
<li><strong>问题分析</strong>：寻找是否存在和为 <code>sum/2</code> 的子集</li>
<li><strong>状态定义</strong>：<code>dp[i][j]</code> 表示前 <code>i</code> 个数字中选出和为 <code>j</code> 的存在性。</li>
<li><strong>状态转移方程</strong>：</li>
<li>拿不下就不拿：<code>if(j&lt;nums[i-1]) dp[i][j]=dp[i-1][j];</code></li>
<li>
<p>拿得下再决定拿不拿：<code>else dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i-1]];</code></p>
</li>
<li>
<p><strong>最终目标</strong>：<code>dp[n][p]</code></p>
</li>
<li><strong>边界条件与限制</strong>：<code>dp[0][0]=true</code> 和 <code>sum</code> 必须是偶数</li>
</ul>
<p>
<div class="code-container">
<div class="code-tabs">
<button class="tab-btn active" data-lang="python">Python</button>
<button class="tab-btn" data-lang="cpp">C++</button>
</div>
<div class="code-blocks">
<pre class="code-block active" data-lang="python"><code class="language-python"># 此部分代码待实现</code></pre>
<pre class="code-block" data-lang="cpp"><code class="language-cpp">bool canPartition(vector&lt;int&gt;&amp; nums) {
    int sum = 0, n=nums.size();
    for(int i=0;i&lt;n;i++) sum+=nums[i];
    if(sum%2!=0) return false;
    int p = sum/2;
    vector&lt;vector&lt;int&gt;&gt; dp(n+1,vector&lt;int&gt;(p+1,false));
    dp[0][0]=true;
    for(int i=1;i&lt;=n;i++){
        for(int j=0;j&lt;=p;j++){
            if(j&lt;nums[i-1]) dp[i][j]=dp[i-1][j];
            else dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i-1]];
        }
    }
    return dp[n][p];
}</code></pre>
</div>
</div>
</p>
<ul>
<li><strong>空间优化</strong>：<code>dp[i][j]</code> 仅依赖于 <code>dp[i-1][j]</code> 和 <code>dp[i-1][j-nums[i-1]]</code>，即上一行的数据</li>
<li><code>dp[j]</code>：容量为 <code>j</code> 时的可行性</li>
<li><code>dp[j] = dp[j] || dp[j-nums[i]];</code></li>
</ul>
<p>
<div class="code-container">
<div class="code-tabs">
<button class="tab-btn active" data-lang="python">Python</button>
<button class="tab-btn" data-lang="cpp">C++</button>
</div>
<div class="code-blocks">
<pre class="code-block active" data-lang="python"><code class="language-python"># 此部分代码待实现</code></pre>
<pre class="code-block" data-lang="cpp"><code class="language-cpp">bool canPartition(vector&lt;int&gt;&amp; nums) {
    int sum = 0, n=nums.size();
    for(int i=0;i&lt;n;i++) sum+=nums[i];
    if(sum%2!=0) return false;
    sum/=2;
    vector&lt;int&gt; dp(sum+1,false);
    dp[0]=true;
    for(int i=0;i&lt;n;i++){
        for(int j=sum;j&gt;=nums[i];j--){
            dp[j] = dp[j] || dp[j-nums[i]];
        }
    }
    return dp[sum];
}</code></pre>
</div>
</div>
</p>
<p><a href="https://leetcode.cn/problems/target-sum/">494. 目标和 - 力扣（LeetCode）</a></p>
<p><strong>问题</strong>：<code>nums</code>每个数字前添加 <code>+</code> 或 <code>-</code>，使得表达式的运算结果等于 <code>target</code>，求共有多少种组合方式</p>
<ul>
<li><strong>问题分析</strong>：设正数子集为 P，负数子集为 N；已知：</li>
<li><code>P-N=target</code></li>
<li><code>P+N=sum(nums)</code></li>
<li>联立得：<code>P=(target+sum(nums))/2</code>，将问题转化为：在数组中选取若干数，使得它们的和等于 <code>P</code>（01 背包）</li>
<li><strong>状态定义</strong>：<code>dp[i][j]</code>表示前 <code>i</code> 个数字中选出和为 <code>j</code> 的方案数。</li>
<li><strong>状态转移方程</strong>：</li>
<li>当 <code>j</code> 小于 <code>nums[i]</code> 时，不选择：<code>dp[i][j] = dp[i-1][j]</code></li>
<li>否则，合并是否选择的结果：<code>dp[i][j] = dp[i-1][j]+dp[i-1][j - nums[i]]</code></li>
<li><strong>最终目标</strong>：<code>dp[n][p]</code></li>
<li><strong>边界条件与限制</strong>：</li>
<li><strong>必要条件</strong>：<code>target+sum(nums)</code> 必须是非负偶数，且 <code>sum(nums)&gt;=target</code></li>
<li><strong>初始化</strong>：<code>dp[0][0]=1</code>（空集合和为0的方案数为1）</li>
</ul>
<p>
<div class="code-container">
<div class="code-tabs">
<button class="tab-btn active" data-lang="python">Python</button>
<button class="tab-btn" data-lang="cpp">C++</button>
</div>
<div class="code-blocks">
<pre class="code-block active" data-lang="python"><code class="language-python"># 此部分代码待实现</code></pre>
<pre class="code-block" data-lang="cpp"><code class="language-cpp">int findTargetSumWays(vector&lt;int&gt;&amp; nums, int target) {
    int n = nums.size();
    int p=0;
    for(int i=0;i&lt;n;i++) p+=nums[i]; 
    if(p&lt;target) return 0;
    p += target;
    if(p%2!=0 || p&lt;0) return 0;
    p/=2;
    vector&lt;vector&lt;int&gt;&gt; dp(n+1, vector&lt;int&gt;(p+1,0));
    dp[0][0]=1; // 空组和为0，相当于有一种方案 
    for(int i=1;i&lt;=n;i++){
        for(int j=0;j&lt;=p;j++){
            if(j&lt;nums[i-1]) dp[i][j]=dp[i-1][j]; //没法选
            else dp[i][j]=dp[i-1][j]+dp[i-1][j-nums[i-1]]; //不选这个数方案数+选这个数方案数
        }
    }
    return dp[n][p];
}</code></pre>
</div>
</div>
</p>
<ul>
<li><strong>空间优化</strong>：<code>dp[i][j]</code> 仅依赖于 <code>dp[i-1][j]</code> 和 <code>dp[i-1][j-nums[i-1]]</code>，即上一行的数据</li>
<li><code>dp[j]</code>：容量为 <code>j</code> 时的方案数</li>
<li><code>dp[j]=dp[j]+dp[j-nums[i]];</code></li>
</ul>
<p>
<div class="code-container">
<div class="code-tabs">
<button class="tab-btn active" data-lang="python">Python</button>
<button class="tab-btn" data-lang="cpp">C++</button>
</div>
<div class="code-blocks">
<pre class="code-block active" data-lang="python"><code class="language-python"># 此部分代码待实现</code></pre>
<pre class="code-block" data-lang="cpp"><code class="language-cpp">int findTargetSumWays(vector&lt;int&gt;&amp; nums, int target) {
    // `P=(target+sum(nums))/2`
    // 将问题转化为：在数组中选取若干数，使得它们的和等于 `P`（01 背包）
    int n = nums.size();
    int p=0;
    for(int i=0;i&lt;n;i++) p+=nums[i]; 
    if(p&lt;target) return 0;
    p += target;
    if(p%2!=0 || p&lt;0) return 0;
    p/=2;
    vector&lt;int&gt; dp(p+1,0);
    dp[0]=1; // 空组和为0，相当于有一种方案 
    for(int i=0;i&lt;n;i++){
        for(int j=p;j&gt;=nums[i];j--){
            dp[j]=dp[j]+dp[j-nums[i]]; //不选这个数方案数+选这个数方案数
        }
    }
    return dp[p];
}</code></pre>
</div>
</div>
</p>
<p><a href="https://leetcode.cn/problems/ones-and-zeroes/description/">474. 一和零 - 力扣（LeetCode）</a></p>
<p><strong>问题</strong>：给定一个二进制字符串数组 <code>strs</code> 和两个整数 <code>m</code> 和 <code>n</code>，分别表示允许使用的 <code>0</code> 和 <code>1</code> 的最大数量。要求找出并返回能组成的最大子集的大小，该子集中 <code>0</code> 和 <code>1</code> 的数量不超过 <code>m</code> 和 <code>n</code>。</p>
<p>（当你已经熟悉了 0-1 背包的空间优化，就应该直接把它作为入手点了，不需要再从普通情况入手，无非就三部曲：1.背包里面没有 i，2.容量倒序，3.下界为物品重量)</p>
<p>（注意，并不是所有背包问题都可以空间优化，当且仅当不存在多维约束（标准背包）且不用记录路径的问题可以）</p>
<ul>
<li><strong>问题分析</strong>：题目中给出了两个费用，这是<strong>二维 0-1 背包问题</strong></li>
<li><strong>状态定义</strong>：<code>dp[j][k]</code> 表示使用 <code>j</code> 个 <code>0</code> 和 <code>k</code> 个 <code>1</code> 时能组成的最大子集大小</li>
<li><strong>状态转移</strong>：对于每个字符串，统计其 <code>0</code> 的数量 <code>zeros</code> 和 <code>1</code> 的数量 <code>ones</code></li>
<li><strong>最终目标</strong>：<code>dp[m][n]</code></li>
<li><strong>边界条件与限制</strong>：<code>dp[0][0]=0</code></li>
</ul>
<p>
<div class="code-container">
<div class="code-tabs">
<button class="tab-btn active" data-lang="python">Python</button>
<button class="tab-btn" data-lang="cpp">C++</button>
</div>
<div class="code-blocks">
<pre class="code-block active" data-lang="python"><code class="language-python"># 此部分代码待实现</code></pre>
<pre class="code-block" data-lang="cpp"><code class="language-cpp">int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) {
    vector&lt;vector&lt;int&gt;&gt; dp(m+1,vector&lt;int&gt;(n+1,0));
    dp[0][0]=0;
    for(int i=0;i&lt;strs.size();i++){
        int zero =0, one=0;
        for(int j=0;j&lt;strs[i].size();j++){
            if(strs[i][j]=='0') zero++;
            else one++;
        }
        for(int j=m;j&gt;=zero;j--){
            for(int k=n;k&gt;=one;k--){
                dp[j][k]=max(dp[j][k], dp[j-zero][k-one]+1);
            }
        }
    }
    return dp[m][n];
}</code></pre>
</div>
</div>
</p>
<p><a href="https://leetcode.cn/problems/profitable-schemes/">879. 盈利计划 - 力扣（LeetCode）</a></p>
<p><strong>问题</strong>：总有 <code>n</code> 名员工，第 <code>i</code> 种工作会产生 <code>profit[i]</code> 的利润，它要求 <code>group[i]</code> 名成员共同参与。如果成员参与了其中一项工作，就不能参与另一项工作。工作的任何至少产生 <code>minProfit</code> 利润的子集称为 <strong>盈利计划</strong> 。并且工作的成员总数最多为 <code>n</code> 。有多少种计划可以选择？因为答案很大，所以 <strong>返回结果模</strong> <code>10^9 + 7</code> <strong>的值</strong>。</p>
<ul>
<li><strong>问题分析</strong>：各个工作的用人求和 &lt;=n，利润 &gt;= minProfit，是<strong>双限制的背包问题</strong>；背包内容是方案数（求和）；一种工作只能选一次，认为是 01 背包</li>
<li><strong>状态定义</strong>：<code>dp[i][j][k]</code>：前i个工作，容量为 j,利润至少为 k 的方案数</li>
<li><strong>状态转移</strong>：</li>
<li>不选：<code>dp[i-1][j][k]</code></li>
<li>选：<code>dp[i-1][j-group[i-1]][max(k-profit[i-1], 0)]</code></li>
<li>状态选择函数：<code>+</code></li>
<li><strong>最终目标</strong>：<code>dp[m][n][minProfit]</code></li>
<li><strong>边界条件与限制</strong>：<code>dp[0][j][0]=1</code>：不使用任何物品，且利润为 0 的方案数唯一，且与人数无关</li>
</ul>
<p>
<div class="code-container">
<div class="code-tabs">
<button class="tab-btn active" data-lang="python">Python</button>
<button class="tab-btn" data-lang="cpp">C++</button>
</div>
<div class="code-blocks">
<pre class="code-block active" data-lang="python"><code class="language-python"># 此部分代码待实现</code></pre>
<pre class="code-block" data-lang="cpp"><code class="language-cpp">int mod = (int)1e9+7;
int profitableSchemes(int n, int minProfit, vector&lt;int&gt;&amp; group, vector&lt;int&gt;&amp; profit) {
    // dp[i][j][k] = dp[i-1][j][k] + dp[i-1][j-g[i]][k-p[i]]+1
    int m = group.size();
    vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(m+1, vector&lt;vector&lt;int&gt;&gt;(n+1, vector&lt;int&gt;(minProfit+1)));
    for(int j=0;j&lt;=n;j++)    dp[0][j][0]=1;

    for(int i=1;i&lt;=m;i++){
        for(int j=0;j&lt;=n;j++){
            for(int k=0;k&lt;=minProfit;k++){
                if(j&gt;=group[i-1])
                    dp[i][j][k] = dp[i-1][j][k] + dp[i-1][j-group[i-1]][max(k-profit[i-1], 0)];
                else dp[i][j][k] = dp[i-1][j][k];
                if(dp[i][j][k]&gt;mod) dp[i][j][k]-=mod;
            }
        }
    }
    return dp[m][n][minProfit];
}</code></pre>
</div>
</div>
</p>
<p><strong>空间优化</strong>：</p>
<p>
<div class="code-container">
<div class="code-tabs">
<button class="tab-btn active" data-lang="python">Python</button>
<button class="tab-btn" data-lang="cpp">C++</button>
</div>
<div class="code-blocks">
<pre class="code-block active" data-lang="python"><code class="language-python"># 此部分代码待实现</code></pre>
<pre class="code-block" data-lang="cpp"><code class="language-cpp">int mod = (int)1e9+7;
int profitableSchemes(int n, int minProfit, vector&lt;int&gt;&amp; group, vector&lt;int&gt;&amp; profit) {
    // dp[j][k]: 容量为 j, 利润至少为 k 的方案数
    // dp[j][k] = dp[i-1][j][k] + dp[i-1][j-g[i]][k-p[i]]+1
    int m = group.size();
    vector&lt;vector&lt;int&gt;&gt; dp(n+1, vector&lt;int&gt;(minProfit+1));
    for(int j=0;j&lt;=n;j++)    dp[j][0]=1;

    for(int i=1;i&lt;=m;i++){
        for(int j=n;j&gt;=group[i-1];j--){
            for(int k=minProfit;k&gt;=0;k--){
                dp[j][k] += dp[j-group[i-1]][max(k-profit[i-1], 0)];
                if(dp[j][k]&gt;mod) dp[j][k]-=mod;
            }
        }
    }
    return dp[n][minProfit];
}</code></pre>
</div>
</div>
</p>
<h4 id="_22">完全背包</h4>
<p><strong>核心特点</strong>：有 n 种物品，每种物品可以重复使用，每个物品有自己的重量和价值</p>
<p><strong>关键难点</strong>：难点在于问题转化，不会那么直白得提问，需要化归</p>
<p>🎯 <strong>状态转移套路</strong>：<code>dp[i][j]=f(dp[i-1][j], dp[i][j-w[i]]+v[i])</code>，完全背包由于 ”能拿无限次” 的特点，其前驱状态从 <code>dp[i-1][j]</code> 和 <code>dp[i][...]</code> 中进行转移，具体证明可以参考：</p>
<p><img alt="6" src="figure/6.png" style="zoom:50%;"/></p>
<ul>
<li>拿不下就不拿：<code>if(j&lt;w[i]) dp[i][j]=dp[i-1][j]</code></li>
<li>拿得下再决定：<code>else dp[i][j]=g(dp[i-1][j], dp[i-1][j-w[i]]+v[i])</code>，其中 <code>g</code> 是价值函数，用于衡量拿和不拿哪一个状态对目标有利，常见有：<code>max</code>，<code>min</code>，<code>||</code></li>
<li>求值：<code>dp[i][j]=max(dp[i-1][j],dp[i-1][j-w[i]]+v[i])</code></li>
<li>空间优化：与 0-1 背包不同，因为完全背包允许重复选择，所以允许覆盖，可以正序更新</li>
</ul>
<p><a href="https://leetcode.cn/problems/coin-change/description/">322. 零钱兑换 - 力扣（LeetCode）</a></p>
<p><strong>问题</strong>：假设有无限数量的硬币，面额为 <code>coins</code>，需要凑出总金额 <code>amount</code>。求最少需要多少枚硬币？</p>
<ul>
<li><strong>问题分析</strong>：经典的完全背包，“无限数量” 求 “最少”</li>
<li><strong>状态定义</strong>：<code>dp[i][j]</code>表示前 <code>i</code> 种硬币中凑出金额为 <code>w</code> 的最少硬币数。</li>
<li><strong>状态转移方程</strong>：</li>
<li>当 <code>j</code> 小于 <code>coins[i-1]</code> 时，不选择：<code>dp[i][j] = dp[i-1][j]</code></li>
<li>否则，比较决定是否选择：<code>dp[i][j] = min(dp[i-1][j],dp[i][j-coins[i-1]] + 1)</code></li>
<li><strong>最终目标</strong>：<code>dp[n][p]</code></li>
<li><strong>边界条件与限制</strong>：</li>
<li><strong>初始化</strong>：<code>dp[0][0]=0</code>，<code>dp[0][j]=INT_MAX</code></li>
</ul>
<p>
<div class="code-container">
<div class="code-tabs">
<button class="tab-btn active" data-lang="python">Python</button>
<button class="tab-btn" data-lang="cpp">C++</button>
</div>
<div class="code-blocks">
<pre class="code-block active" data-lang="python"><code class="language-python"># 此部分代码待实现</code></pre>
<pre class="code-block" data-lang="cpp"><code class="language-cpp">int coinChange(vector&lt;int&gt;&amp; coins, int amount) {
    int n = coins.size();
    vector&lt;vector&lt;int&gt;&gt; dp(n+1,vector&lt;int&gt;(amount+1,INT_MAX-1));
    dp[0][0]=0;
    for(int i=1;i&lt;=n;i++){ //遍历物品
        for(int j=0;j&lt;amount+1;j++){ //遍历容量
            if(j&lt;coins[i-1]) dp[i][j]=dp[i-1][j];
            else dp[i][j]=min(dp[i-1][j], dp[i][j-coins[i-1]]+1);
        }
    }
    return dp[n][amount]==INT_MAX-1? -1 : dp[n][amount];
}</code></pre>
</div>
</div>
</p>
<ul>
<li><strong>空间优化</strong>：<code>dp[i][j]</code> 仅依赖于 <code>dp[i-1][j]</code> 和 <code>dp[i][j - coins[i-1]]</code></li>
<li><code>dp[j]</code>：凑出金额 <code>j</code> 所需的最少硬币数</li>
<li><code>dp[j] = min(dp[j],dp[j - coins[i]]+1)</code>，正序更新</li>
</ul>
<p>
<div class="code-container">
<div class="code-tabs">
<button class="tab-btn active" data-lang="python">Python</button>
<button class="tab-btn" data-lang="cpp">C++</button>
</div>
<div class="code-blocks">
<pre class="code-block active" data-lang="python"><code class="language-python"># 此部分代码待实现</code></pre>
<pre class="code-block" data-lang="cpp"><code class="language-cpp">int coinChange(vector&lt;int&gt;&amp; coins, int amount) {
    vector&lt;int&gt; dp(amount+1,INT_MAX-1);
    dp[0]=0;
    for(int i=0;i&lt;coins.size();i++){ //遍历物品
        for(int j=coins[i];j&lt;amount+1;j++){ //遍历容量
            dp[j]=min(dp[j], dp[j-coins[i]]+1);
        }
    }
    return dp[amount]==INT_MAX-1? -1 : dp[amount];
}</code></pre>
</div>
</div>
</p>
<p><a href="https://leetcode.cn/problems/word-break/description/">139. 单词拆分 - 力扣（LeetCode）</a></p>
<p>
<div class="code-container">
<div class="code-tabs">
<button class="tab-btn active" data-lang="python">Python</button>
<button class="tab-btn" data-lang="cpp">C++</button>
</div>
<div class="code-blocks">
<pre class="code-block active" data-lang="python"><code class="language-python"># 此部分代码待实现</code></pre>
<pre class="code-block" data-lang="cpp"><code class="language-cpp">bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) {
    // dp[i]:考虑前i个字母的结果
    int n = s.size();
    vector&lt;bool&gt; dp(n+1, false);
    dp[0] = true;
    for(int i=0;i&lt;=n;i++){ // 遍历容量
        for (const string&amp; word : wordDict) { // 遍历物品
            int len = word.size();  // 检查长度是否足够，且子串匹配
            if (i &gt;= len &amp;&amp; dp[i - len] &amp;&amp; s.substr(i - len, len) == word) {
                dp[i] = true;
                break; // 找到一个可行解即可跳过其他单词
            }
        }
    }
    return dp[n];
}</code></pre>
</div>
</div>
</p>
<p><a href="https://leetcode.cn/problems/perfect-squares/">279. 完全平方数 - 力扣（LeetCode）</a></p>
<p>
<div class="code-container">
<div class="code-tabs">
<button class="tab-btn active" data-lang="python">Python</button>
<button class="tab-btn" data-lang="cpp">C++</button>
</div>
<div class="code-blocks">
<pre class="code-block active" data-lang="python"><code class="language-python"># 此部分代码待实现</code></pre>
<pre class="code-block" data-lang="cpp"><code class="language-cpp">// 此部分代码待实现</code></pre>
</div>
</div>
</p>
<p><a href="https://leetcode.cn/problems/coin-change-ii/description/">518. 零钱兑换 II - 力扣（LeetCode）</a></p>
<p>
<div class="code-container">
<div class="code-tabs">
<button class="tab-btn active" data-lang="python">Python</button>
<button class="tab-btn" data-lang="cpp">C++</button>
</div>
<div class="code-blocks">
<pre class="code-block active" data-lang="python"><code class="language-python"># 此部分代码待实现</code></pre>
<pre class="code-block" data-lang="cpp"><code class="language-cpp">int change(int amount, vector&lt;int&gt;&amp; coins) {
    int n = coins.size();
    vector&lt;double&gt; dp(amount+1, 0);
    dp[0] = 1;
    for(int i=0;i&lt;n;i++){
        for(int j=coins[i];j&lt;=amount;j++)
            dp[j]=dp[j] + dp[j-coins[i]];
    }
    return dp[amount];
}</code></pre>
</div>
</div>
</p>
<h3 id="dp_3">状态机 DP</h3>
<p><strong>核心特点</strong>：问题中存在<strong>多个互斥的状态</strong>，且每个状态会根据操作切换到另一个状态，形成清晰的<strong>状态转移图</strong>。例如，股票买卖中的「持有」和「不持有」状态，打家劫舍中的「偷」和「不偷」状态。</p>
<p>🎯 <strong>状态定义套路</strong></p>
<ol>
<li><strong>定义状态维度</strong>：</li>
<li><code>dp[i][s]</code>: 表示在第 <code>i</code> 个阶段（如第i天）处于状态 <code>s</code> 时的最优解。</li>
<li>状态 <code>s</code> 通常用数字或布尔值表示（如 <code>0</code> 和 <code>1</code> 表示是否持有股票）。</li>
<li><strong>多维状态扩展</strong>：</li>
<li>若存在额外限制（如交易次数），需增加维度：<code>dp[i][k][s]</code>。</li>
</ol>
<p>🎯 <strong>状态转移套路</strong></p>
<ol>
<li><strong>绘制状态转移图</strong>：</li>
<li>明确每个状态如何转换到其他状态。</li>
<li><strong>示例</strong>（含冷冻期的股票买卖）：<ul>
<li>状态 <code>0</code>（不持有，非冷冻期）← 保持不持有 或 从冷冻期转移</li>
<li>状态 <code>1</code>（持有） ← 保持持有 或 从不持有状态买入</li>
<li>状态 <code>2</code>（冷冻期） ← 从持有状态卖出</li>
</ul>
</li>
<li><strong>状态转移方程</strong>：</li>
<li>根据状态转移图，为每个状态写出递推式。</li>
</ol>
<p><strong>空间优化</strong>：</p>
<ol>
<li><strong>滚动数组压缩</strong>：若当前状态仅依赖前一状态，可用变量代替数组。</li>
<li><strong>降维处理</strong>：</li>
<li>若状态维度较高但部分维度可合并，可减少维度。</li>
<li><strong>示例</strong>：当交易次数 <code>k</code> 较大时，可压缩为奇偶滚动（如 <code>dp[2][k]</code>）。</li>
</ol>
<p><a href="https://leetcode.cn/problems/climbing-stairs/description">70. 爬楼梯 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/">123. 买卖股票的最佳时机 III - 力扣（LeetCode）</a></p>
<p><strong>问题</strong>：最多可以完成 <strong>两笔</strong> 交易，不能参与多笔交易</p>
<ul>
<li>
<p><strong>状态定义</strong>：<code>dp[i][j]</code>：在第 <code>i</code> 天以状态 <code>j</code> 获得的最大利润</p>
</li>
<li>
<p>未进行过任何操作（起始态，可以不定义）</p>
</li>
<li>只进行过一次买操作 <code>buy1</code></li>
<li>进行了一次买操作和一次卖操作，即完成了一笔交易 <code>sell1</code></li>
<li>在完成了一笔交易的前提下，进行了第二次买操作 <code>buy2</code></li>
<li>
<p>完成了全部两笔交易 <code>sell2</code></p>
</li>
<li>
<p><strong>状态转移</strong>：根据 <code>i-1</code> 天的状态和利润来决定 <code>i</code> 天的状态，同时我们追求最大利润，选择函数自然是 <code>max</code></p>
</li>
<li>
<p>昨天是起始态：要么转移到 <code>buy1</code>；要么什么都不做：<code>dp[i][0]=max(-prices[i], dp[i-1][0])</code></p>
</li>
<li>昨天是 <code>buy1</code>：要么转移到 <code>sell1</code>；要么什么都不做：<code>dp[i][1]=max(dp[i-1][0]+prices[i], dp[i-1][1])</code></li>
<li>昨天是 <code>sell1</code>：要么转移到 <code>buy2</code>；要么什么都不做：<code>dp[i][2]=max(dp[i-1][1]-prices[i], dp[i-1][2])</code></li>
<li>昨天是 <code>buy2</code>：要么转移到 <code>sell2</code>；要么什么都不做：<code>dp[i][3]=max(dp[i-1][2]+prices[i], dp[i-1][3])</code></li>
</ul>
<p>可以发现，这是一个单向的状态转移，实际上并不困难。注意一个细节，状态转移中所谓的 ”不变“ 指的本质上是状态不变，而不是利润不变，后者只是顺带的效果，因此 <code>max</code> 的对象是昨天的同状态，而不是昨天的前驱状态</p>
<ul>
<li>
<p><strong>最终目标</strong>：最大利润可能在一次或两次交易后，或者不交易：<code>max(dp[n-1][1], dp[n-1][3], 0)</code></p>
</li>
<li>
<p><strong>边界条件与限制</strong>：我们需要通过最小值初始化代表状态还没有发生，以在 <code>max</code> 中自动屏蔽掉未到达的状态</p>
</li>
</ul>
<p>
<div class="code-container">
<div class="code-tabs">
<button class="tab-btn active" data-lang="python">Python</button>
<button class="tab-btn" data-lang="cpp">C++</button>
</div>
<div class="code-blocks">
<pre class="code-block active" data-lang="python"><code class="language-python">def maxProfit(self, prices: List[int]) -&gt; int:
    n = len(prices)
    dp = [[0] * 4 for _ in range(n)]
    dp[0][0] = -prices[0]  # 第一次买入后的利润
    dp[0][1] = 0           # 第一次卖出后的利润
    dp[0][2] = -float('inf') # 第二次买入后的利润，初始不可达
    dp[0][3] = -float('inf') # 第二次卖出后的利润，初始不可达

    for i in range(1, n):
        # 第一次买入状态：保持或当天买入
        dp[i][0] = max(dp[i-1][0], -prices[i])
        # 第一次卖出状态：保持或当天卖出第一次买入的股票
        dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i])
        # 第二次买入状态：保持或当天买入，基于第一次卖出后的利润
        dp[i][2] = max(dp[i-1][2], dp[i-1][1] - prices[i])
        # 第二次卖出状态：保持或当天卖出第二次买入的股票
        dp[i][3] = max(dp[i-1][3], dp[i-1][2] + prices[i])
     return max(dp[-1][1], dp[-1][3], 0)</code></pre>
<pre class="code-block" data-lang="cpp"><code class="language-cpp">int maxProfit(vector&lt;int&gt;&amp; prices) {
    int n = prices.size();
    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(4, 0));
    dp[0][0] = -prices[0];  // 第一次买入后的利润
    dp[0][1] = 0;           // 第一次卖出后的利润
    dp[0][2] = INT_MIN; // 第二次买入后的利润，初始不可达
    dp[0][3] = INT_MIN; // 第二次卖出后的利润，初始不可达
    for(int i=1;i&lt;n;i++){
        // 第一次买入状态：保持或当天买入
        dp[i][0] = max(dp[i-1][0], -prices[i]);
        // 第一次卖出状态：保持或当天卖出第一次买入的股票
        dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i]);
        // 第二次买入状态：保持或当天买入，基于第一次卖出后的利润
        dp[i][2] = max(dp[i-1][2], dp[i-1][1] - prices[i]);
        // 第二次卖出状态：保持或当天卖出第二次买入的股票
        dp[i][3] = max(dp[i-1][3], dp[i-1][2] + prices[i]);
    }
    return max(max(dp[n-1][1], dp[n-1][3]), 0);
}</code></pre>
</div>
</div>
</p>
<p><strong>空间优化</strong>：注意到状态转移只依赖前一天，可以在遍历的过程中丢弃掉之前的数据，压缩优化</p>
<p>
<div class="code-container">
<div class="code-tabs">
<button class="tab-btn active" data-lang="python">Python</button>
<button class="tab-btn" data-lang="cpp">C++</button>
</div>
<div class="code-blocks">
<pre class="code-block active" data-lang="python"><code class="language-python">def maxProfit(self, prices: List[int]) -&gt; int:
    n = len(prices)
    buy1 = -prices[0]  # 第一次买入后的利润
    sell1 = 0           # 第一次卖出后的利润
    buy2 = -float('inf') # 第二次买入后的利润，初始不可达
    sell2 = -float('inf') # 第二次卖出后的利润，初始不可达

    for i in range(1, n):
        buy1 = max(buy1, -prices[i])
        sell1 = max(sell1, buy1 + prices[i])
        buy2 = max(buy2, sell1 - prices[i])
        sell2 = max(sell2, buy2 + prices[i])
    return max(sell1, sell2, 0)</code></pre>
<pre class="code-block" data-lang="cpp"><code class="language-cpp">int maxProfit(vector&lt;int&gt;&amp; prices) {
    int n = prices.size();
    int buy1 = -prices[0];  // 第一次买入后的利润
    int sell1 = 0;           // 第一次卖出后的利润
    int buy2 = INT_MIN; // 第二次买入后的利润，初始不可达
    int sell2 = INT_MIN; // 第二次卖出后的利润，初始不可达
    for(int i=1;i&lt;n;i++){
        buy1 = max(buy1, -prices[i]);            
        sell1 = max(sell1, buy1 + prices[i]);            
        buy2 = max(buy2, sell1 - prices[i]);
        sell2 = max(sell2, buy2 + prices[i]);
    }
    return max(max(sell1, sell2), 0);
}</code></pre>
</div>
</div>
</p>
<p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/">188. 买卖股票的最佳时机 IV - 力扣（LeetCode）</a></p>
<p><strong>通解扩展</strong>：我们可以发现，如果交易数量的限制扩展到 k 次，我们不可能给出静态的 k 组买卖状态，则自然地我们需要一个数组来维护 “k 个状态组”。在空间优化前它实际上已经出现在 <code>dp</code> 数组的第二维度上，而优化后我们也可以使用 <code>buy[k]</code> 和 <code>sell[k]</code> 来表现 </p>
<ul>
<li><code>buy[j]</code>：表示进行第 <code>j</code> 次买入后的最大利润</li>
<li>当前可以是保持之前的买入状态（不操作）。</li>
<li>或者在完成前 <code>j-1</code> 次交易后，以当前价格买入股票，即 <code>sell[j-1] - price</code>。</li>
<li>转移方程：<code>buy[j] = max(buy[j], sell[j-1] - price)</code></li>
<li><code>buy</code> 数组初始化为负无穷，表示初始时无法进行任何交易。</li>
<li><code>sell[j]</code>：表示进行第 <code>j</code> 次卖出后的最大利润</li>
<li>当前可以是保持之前的卖出状态（不操作）。</li>
<li>或者在当前买入后，以当前价格卖出股票，即 <code>buy[j] + price</code>。</li>
<li>转移方程：<code>sell[j] = max(sell[j], buy[j] + price)</code></li>
<li><code>sell</code> 数组初始化为 0，表示交易的利润为 0</li>
</ul>
<p>
<div class="code-container">
<div class="code-tabs">
<button class="tab-btn active" data-lang="python">Python</button>
<button class="tab-btn" data-lang="cpp">C++</button>
</div>
<div class="code-blocks">
<pre class="code-block active" data-lang="python"><code class="language-python">def maxProfit(self, k: int, prices: List[int]) -&gt; int:
    n = len(prices)
    buy = [-float('inf')] * (k+1)
    sell = [0] * (k+1)
    for i in range(0, n):
        for j in range(1, k+1):
            buy[j] = max(buy[j], sell[j-1]-prices[i])
            sell[j] = max(sell[j], buy[j]+prices[i])
    return sell[k]</code></pre>
<pre class="code-block" data-lang="cpp"><code class="language-cpp">int maxProfit(int k, vector&lt;int&gt;&amp; prices) {
    int n = prices.size();
    vector&lt;int&gt; buy(k+1, INT_MIN);
    vector&lt;int&gt; sell(k+1, 0);
    for(int i=0;i&lt;n;i++){
        for(int j=1;j&lt;=k;j++){
            buy[j]=max(buy[j], sell[j-1]-prices[i]);
            sell[j]=max(sell[j], buy[j]+prices[i]);
        }
    }
    return sell[k];
}</code></pre>
</div>
</div>
</p>
<h2 id="_23">技巧</h2>
<h4 id="_24">数组元素的相互抵消运算</h4>
<p>异或运算：<a href="https://leetcode.cn/problems/single-number/">136. 只出现一次的数字 - 力扣（LeetCode）</a></p>
<p>摩尔投票：<a href="https://leetcode.cn/problems/majority-element/description/">169. 多数元素 - 力扣（LeetCode）</a></p>
<h4 id="_25">数学技巧</h4>
<h5 id="_26">矩阵旋转</h5>
<p>旋转 90° 公式：$m[i][j]=m[j][n-1-i]$</p>
<h5 id="_27">因式分解</h5>
<p><a href="https://www.lintcode.com/problem/871/">871 · 最小分解 - LintCode</a></p>
<p><strong>问题</strong>：给定一个正整数<code>a</code>，找到最小的正整数<code>b</code>，它的每个数字相乘之后等于<code>a</code>，如果结果不存在或不是 32 位有符号整数则返回 0</p>
<p><strong>问题分析</strong>：</p>
<ul>
<li>
<p>边界：如果输入的数字是一位的，则直接返回它本身。如果是两位数包括以上且是质数，返回 0</p>
</li>
<li>
<p>题目要求找<strong>最小</strong>的，结合前文单调栈章节的例题，可知此处要求 <code>b</code> 从左往右是<strong>单调不减</strong>的</p>
</li>
<li>基于这个特性，我们不妨试图从右往左确定 <code>b</code> 的每一位，每确定一位的数字，再往前的数字范围也会被修改</li>
<li>基于整除的算法</li>
</ul>
<p>
<div class="code-container">
<div class="code-tabs">
<button class="tab-btn active" data-lang="python">Python</button>
<button class="tab-btn" data-lang="cpp">C++</button>
</div>
<div class="code-blocks">
<pre class="code-block active" data-lang="python"><code class="language-python">def smallest_factorization(self, a: int) -&gt; int:
    if a&lt;10: return a;
    b, t, cur = 0, 9, 1
    while(a&gt;1):
        if a%t==0:
            b += t*cur
            cur *= 10
            a/=t
        else:
            t-=1
            if t==1: break
    if a!=1 or b&gt;2147483647: return 0
    return b</code></pre>
<pre class="code-block" data-lang="cpp"><code class="language-cpp">int smallestFactorization(int a) {
    if(a&lt;10) return a;
    int b=0;
    int t=9, cur=1;
    while(a&gt;1){
        if(a%t==0){
            b += t*cur;
            cur *= 10;
            a/=t;
        }
        else{
            t--;
            if(t==1) break;
        }
    }
    if(a!=1 or b&lt;0) return 0;
    return b;
}</code></pre>
</div>
</div>
</p>
<h5 id="_28">均值不等式</h5>
<p><a href="https://leetcode.cn/problems/integer-break/description/">343. 整数拆分 - 力扣（LeetCode）</a></p></section>
    </main>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js"></script>
    <script src="script.js"></script>
</body>
</html>