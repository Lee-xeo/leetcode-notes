<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LeetCode笔记</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif:wght@400;700&family=Libre+Baskerville:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
    <nav class="sidebar">
        <div class="sidebar-header">
            <h2>目录</h2>
        </div>
        <ul id="toc">
            <!-- 目录将由JavaScript生成 -->
        </ul>
    </nav>
    
    <main id="content">
        <h1>LeetCode笔记</h1>
        
        <!-- 工具包 - 二分查找 -->
        <section id="binary-search">
            <h2>工具包</h2>
            <h3>二分查找</h3>
            
            <p>查找给定值，存在则返回索引，否则返回-1：</p>
            
            <div class="code-container">
                <div class="code-tabs">
                    <button class="tab-btn active" data-lang="python">Python</button>
                    <button class="tab-btn" data-lang="cpp">C++</button>
                </div>
                
                <div class="code-blocks">
                    <pre class="code-block active" data-lang="python"><code class="language-python"># 迭代版本
def binary_search(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1
# 递归版本
def binary_search(nums, target, left, right):
    if left > right:
        return -1
    mid = (left + right) // 2
    if nums[mid] == target:
        return mid
    elif nums[mid] < target:
        return binary_search(nums, target, mid + 1, right)
    else:
        return binary_search(nums, target, left, mid - 1)</code></pre>
                    
                    <pre class="code-block" data-lang="cpp"><code class="language-cpp">// 迭代版本
int binarySearch(vector<int>& nums, int target) {
    int left = 0, right = nums.size() - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            return mid;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return -1;
}
// 递归版本
int binarySearch(vector<int>& nums, int target, int left, int right) {
    if (left > right) {
        return -1;
    }
    int mid = left + (right - left) / 2;
    if (nums[mid] == target) {
        return mid;
    } else if (nums[mid] < target) {
        return binarySearch(nums, target, mid + 1, right);
    } else {
        return binarySearch(nums, target, left, mid - 1);
    }
}</code></pre>
                </div>
            </div>
            
            <p>查找比给定值小的最大元素（下界）:</p>
            
            <div class="code-container">
                <div class="code-tabs">
                    <button class="tab-btn active" data-lang="python">Python</button>
                    <button class="tab-btn" data-lang="cpp">C++</button>
                </div>
                
                <div class="code-blocks">
                    <pre class="code-block active" data-lang="python"><code class="language-python"># 迭代版本
def find_lower_bound(nums, target):
    left, right = 0, len(nums) - 1
    i = len(nums)  # 初始化假设所有元素都小于target
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] >= target:
            i = mid
            right = mid - 1
        else:
            left = mid + 1
    return i - 1 if i != 0 else -1
# 递归版本
def find_lower_bound(nums, target, left, right):
    if left > right:
        return right  # 返回比target小的最大元素的索引
    mid = (left + right) // 2
    if nums[mid] >= target:
        return find_lower_bound(nums, target, left, mid - 1)
    else:
        return find_lower_bound(nums, target, mid + 1, right)</code></pre>
                    
                    <pre class="code-block" data-lang="cpp"><code class="language-cpp">// 迭代版本
int findLowerBound(vector<int>& nums, int target) {
    int left = 0, right = nums.size() - 1;
    int i = nums.size();  // 初始化假设所有元素都小于target
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] >= target) {
            i = mid;
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    return i == 0 ? -1 : i - 1;
}
// 递归版本
int findLowerBound(vector<int>& nums, int target, int left, int right) {
    if (left > right) {
        return right;  // 返回比target小的最大元素的索引
    }
    int mid = left + (right - left) / 2;
    if (nums[mid] >= target) {
        return findLowerBound(nums, target, left, mid - 1);
    } else {
        return findLowerBound(nums, target, mid + 1, right);
    }
}</code></pre>
                </div>
            </div>
            
            <p>查找比给定值大的最小元素（上界）:</p>
            
            <div class="code-container">
                <div class="code-tabs">
                    <button class="tab-btn active" data-lang="python">Python</button>
                    <button class="tab-btn" data-lang="cpp">C++</button>
                </div>
                
                <div class="code-blocks">
                    <pre class="code-block active" data-lang="python"><code class="language-python"># 迭代版本
def find_upper_bound(nums, target):
    left, right = 0, len(nums) - 1
    i = len(nums)  # 初始化假设所有元素都小于等于target
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] > target:
            i = mid
            right = mid - 1
        else:
            left = mid + 1
    return i if i != len(nums) else -1
# 递归版本
def find_upper_bound(nums, target, left, right):
    if left > right:
        return left if left < len(nums) else -1  # 返回比target大的最小元素的索引
    mid = (left + right) // 2
    if nums[mid] > target:
        return find_upper_bound(nums, target, left, mid - 1)
    else:
        return find_upper_bound(nums, target, mid + 1, right)</code></pre>
                    
                    <pre class="code-block" data-lang="cpp"><code class="language-cpp">// 迭代版本
int findUpperBound(vector<int>& nums, int target) {
    int left = 0, right = nums.size() - 1;
    int i = nums.size();  // 初始化假设所有元素都小于等于target
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] > target) {
            i = mid;
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    return i != nums.size() ? i : -1;
}
// 递归版本
int findUpperBound(vector<int>& nums, int target, int left, int right) {
    if (left > right) {
        return left < nums.size() ? left : -1;  // 返回比target大的最小元素的索引
    }
    int mid = left + (right - left) / 2;
    if (nums[mid] > target) {
        return findUpperBound(nums, target, left, mid - 1);
    } else {
        return findUpperBound(nums, target, mid + 1, right);
    }
}</code></pre>
                </div>
            </div>
            
            <p>注：在以上算法中，<code>if</code> 递归条件中改为非严格符号，就能处理有相同元素时的问题</p>
        </section>
        
        <!-- 快慢指针 -->
        <section id="two-pointers">
            <h3>快慢指针</h3>
            
            <p>取链表中点</p>
            
            <div class="code-container">
                <div class="code-tabs">
                    <button class="tab-btn active" data-lang="python">Python</button>
                    <button class="tab-btn" data-lang="cpp">C++</button>
                </div>
                
                <div class="code-blocks">
                    <pre class="code-block active" data-lang="python"><code class="language-python">while fast and fast.next:
    fast, slow = fast.next.next, slow.next
mid = slow.next</code></pre>
                    
                    <pre class="code-block" data-lang="cpp"><code class="language-cpp">while (fast != nullptr && fast->next != nullptr) {
    fast = fast->next->next;
    slow = slow->next;
}
ListNode* mid = slow->next;</code></pre>
                </div>
            </div>
            
            <p>找环形入口</p>
            
            <p><a href="https://leetcode.cn/problems/find-the-duplicate-number/" target="_blank">287. 寻找重复数 - 力扣（LeetCode）</a></p>
        </section>
        
        <!-- 数组元素的相互抵消运算 -->
        <section id="array-cancel">
            <h3>数组元素的相互抵消运算</h3>
            
            <ul>
                <li>异或运算：<a href="https://leetcode.cn/problems/single-number/" target="_blank">136. 只出现一次的数字 - 力扣（LeetCode）</a></li>
                <li>摩尔投票：<a href="https://leetcode.cn/problems/majority-element/description/" target="_blank">169. 多数元素 - 力扣（LeetCode）</a></li>
            </ul>
        </section>
        
        <!-- 滑动窗口 -->
        <section id="sliding-window">
            <h3>滑动窗口</h3>
            
            <p>滑动窗口仅适用于单调数组，即右扩展</p>
            
            <p><a href="https://leetcode.cn/problems/minimum-window-substring/description" target="_blank">76. 最小覆盖子串 - 力扣（LeetCode）</a></p>
        </section>
        
        <!-- 单调栈 -->
        <section id="monotonic-stack">
            <h3>单调栈</h3>
            
            <p>在 O(n) 内解决 "左/右边下一个更大/更小元素" 问题（广义：在一维数组中找第一个满足某种条件的数）：</p>
            
            <ul>
                <li>单调递增栈：从栈顶到栈底递增（口诀：<strong>递增栈找第一大</strong>）
                    <ul>
                        <li>满足递增：入栈时判断栈顶是否比自己<strong>小</strong>，如果是则弹出；直到<strong>栈空</strong>或栈顶<strong>不小于</strong>自身，入栈</li>
                        <li>当从左到右顺序遍历入栈时，入栈前的元素就是<strong>左边第一个比自己大的元素</strong></li>
                    </ul>
                </li>
                <li>单调递减栈：从栈顶到栈底递减（口诀：<strong>递减栈找第一小</strong>）
                    <ul>
                        <li>入栈时判断栈顶是否比自己<strong>大</strong></li>
                        <li>如果是则弹出，直到栈顶<strong>不大于</strong>自身，入栈</li>
                        <li>当从左到右顺序遍历入栈时，入栈前的元素就是<strong>左边第一个比自己小的元素</strong></li>
                    </ul>
                </li>
            </ul>
            
            <p>单调栈是非常好用的数据结构，为了避免脑子卡住：</p>
            
            <ul>
                <li>先记住口诀：减小增大（顺着的）</li>
                <li>再记模板：单调栈三部曲</li>
            </ul>
            
            <div class="code-container">
                <div class="code-tabs">
                    <button class="tab-btn active" data-lang="python">Python</button>
                    <button class="tab-btn" data-lang="cpp">C++</button>
                </div>
                
                <div class="code-blocks">
                    <pre class="code-block active" data-lang="python"><code class="language-python">while 栈非空 and 单调性不满足（这里是排除，排除不严格结果就严格）:
    出栈
if 栈空:    边界处理
else: r[i]=栈顶
无条件入栈 a[i]</code></pre>
                    
                    <pre class="code-block" data-lang="cpp"><code class="language-cpp">while (!stack.empty() && !满足单调性条件) {
    stack.pop();
}
if (stack.empty()) {
    // 边界处理
} else {
    r[i] = stack.top();
}
stack.push(a[i]);</code></pre>
                </div>
            </div>
            
            <p>然后理解：单调栈的精髓在于<strong>单向遮盖</strong>：对于从左向右遍历的递减栈来说，当它遇到一个值，栈中所有比它大的值都会被踢出，这个值就相当于遮盖了它左边所有比它大的值，标记出了新的左侧下界，但又保留了比自己更小的值</p>
            
            <p>（一般在实际应用中维护的是索引，结果序列的初试默认值为 -1，最终值为 -1 则代表没有，也就是单向极值）：</p>
            
            <div class="code-container">
                <div class="code-tabs">
                    <button class="tab-btn active" data-lang="python">Python</button>
                    <button class="tab-btn" data-lang="cpp">C++</button>
                </div>
                
                <div class="code-blocks">
                    <pre class="code-block active" data-lang="python"><code class="language-python">def next_greater(nums):
    greater_stack = []
    answer = [-1]*len(nums)    # 初始化全 -1
    for i in range(len(nums)):
        while greater_stack and nums[i]>nums[greater_stack[-1]]: # 栈底在末位
            index = greater_stack.pop()
            answer[index] = nums[i]
        greater_stack.append(i)
    return answer</code></pre>
                    
                    <pre class="code-block" data-lang="cpp"><code class="language-cpp">vector<int> nextGreater(vector<int>& nums) {
    stack<int> greaterStack;
    vector<int> answer(nums.size(), -1);  // 初始化全 -1
    for (int i = 0; i < nums.size(); i++) {
        while (!greaterStack.empty() && nums[i] > nums[greaterStack.top()]) { // 栈底在末位
            int index = greaterStack.top();
            greaterStack.pop();
            answer[index] = nums[i];
        }
        greaterStack.push(i);
    }
    return answer;
}</code></pre>
                </div>
            </div>
            
            <p>⭐<a href="https://leetcode.cn/problems/trapping-rain-water/description" target="_blank">42. 接雨水 - 力扣（LeetCode）</a></p>
            
            <p>思路：按列求，每次只关注一列（而不是块区域，这个聚焦思想很重要），一个列能够接雨水的量：取决于：<code>min(左边的最高值，右边的最高值）-当前列高</code>，于是我们只需要获得：</p>
            
            <ul>
                <li>向左看的最高列数组<code>l</code></li>
                <li>向右看的最高列数组<code>r</code></li>
                <li>本列的高度输入（输入）<code>a</code></li>
            </ul>
            
            <p>就可以得到答案数组<code>res[i]=min(l[i],r[i])-a[i]</code>，对 <code>res</code> 的所有非 0 项求和即可</p>
            
            <div class="code-container">
                <div class="code-tabs">
                    <button class="tab-btn active" data-lang="cpp">C++</button>
                    <button class="tab-btn" data-lang="python">Python</button>
                </div>
                
                <div class="code-blocks">
                    <pre class="code-block active" data-lang="cpp"><code class="language-cpp">int trap(vector<int>& height) {
    int n = height.size();
    int h = 0;
    vector<int> l(n), r(n), res(n);
    for(int i=0;i<n;i++){
        l[i] = h;
        if(height[i]>h) h = height[i];
    }
    h = 0;
    for(int i=n-1;i>=0;i--){
        r[i] = h;
        if(height[i]>h) h = height[i];
    }
    int ans = 0;
    for(int i=0;i<n;i++){
        res[i]=min(l[i], r[i]) - height[i];
        if(res[i]>0) ans+=res[i];
    }
    return ans;
}</code></pre>
                    
                    <pre class="code-block" data-lang="python"><code class="language-python">def trap(height):
    n = len(height)
    h = 0
    l, r, res = [0] * n, [0] * n, [0] * n
    
    for i in range(n):
        l[i] = h
        if height[i] > h:
            h = height[i]
    
    h = 0
    for i in range(n-1, -1, -1):
        r[i] = h
        if height[i] > h:
            h = height[i]
    
    ans = 0
    for i in range(n):
        res[i] = min(l[i], r[i]) - height[i]
        if res[i] > 0:
            ans += res[i]
    
    return ans</code></pre>
                </div>
            </div>
            
            <p><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/description" target="_blank">84. 柱状图中最大的矩形 - 力扣（LeetCode）</a></p>
            
            <p>经典单调栈题目</p>
            
            <div class="code-container">
                <div class="code-tabs">
                    <button class="tab-btn active" data-lang="cpp">C++</button>
                    <button class="tab-btn" data-lang="python">Python</button>
                </div>
                
                <div class="code-blocks">
                    <pre class="code-block active" data-lang="cpp"><code class="language-cpp">class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        // 对于i列，矩形大小为：左边最远不小于自己的，右边最远不小于自己的
        int n = heights.size();
        if(n==0) return heights[0];
        stack<int> s;
        vector<int> left(n), right(n);
        // 从左往右，找左边严格小,严格单调递减栈
        for(int i=0;i<n;i++){
            while(!s.empty() && heights[s.top()]>=heights[i])    s.pop();
            if(s.empty())   left[i] = -1;
            else    left[i] = s.top();
            s.push(i); 
        }
        while(!s.empty()) s.pop();
        // 从右往左，找右边严格小,严格单调递减栈
        for(int i=n-1;i>=0;i--){
            while(!s.empty() && heights[s.top()]>=heights[i])    s.pop();
            if(s.empty())   right[i] = n;
            else    right[i] = s.top();
            s.push(i); 
        }
        // 计算答案
        int maxa = 0;
        for(int i=0;i<n;i++){
            maxa = max(maxa, heights[i]*(right[i]-left[i]-1));
        }
        return maxa;
    }
};</code></pre>
                    
                    <pre class="code-block" data-lang="python"><code class="language-python">class Solution:
    def largestRectangleArea(self, heights):
        # 对于i列，矩形大小为：左边最远不小于自己的，右边最远不小于自己的
        n = len(heights)
        if n == 0:
            return heights[0]
        
        s = []
        left, right = [0] * n, [0] * n
        
        # 从左往右，找左边严格小,严格单调递减栈
        for i in range(n):
            while s and heights[s[-1]] >= heights[i]:
                s.pop()
            left[i] = -1 if not s else s[-1]
            s.append(i)
        
        s = []
        # 从右往左，找右边严格小,严格单调递减栈
        for i in range(n-1, -1, -1):
            while s and heights[s[-1]] >= heights[i]:
                s.pop()
            right[i] = n if not s else s[-1]
            s.append(i)
        
        # 计算答案
        maxa = 0
        for i in range(n):
            maxa = max(maxa, heights[i] * (right[i] - left[i] - 1))
        
        return maxa</code></pre>
                </div>
            </div>
            
            <!-- 更多代码示例... -->
        </section>
        
        <!-- 单调队列 -->
        <section id="monotonic-queue">
            <h3>单调队列</h3>
            
            <p><a href="https://leetcode.cn/problems/sliding-window-maximum/description" target="_blank">239. 滑动窗口最大值 - 力扣（LeetCode）</a></p>
        </section>
        
        <!-- 前缀和 -->
        <section id="prefix-sum">
            <h3>前缀和</h3>
            
            <p><a href="https://leetcode.cn/problems/subarray-sum-equals-k/description" target="_blank">560. 和为 K 的子数组 - 力扣（LeetCode）</a></p>
            
            <p><a href="https://leetcode.cn/problems/path-sum-iii/description" target="_blank">437. 路径总和 III - 力扣（LeetCode）</a></p>
        </section>
        
        <!-- 动态规划 -->
        <section id="dp">
            <h2>动态规划</h2>
            
            <h3>思想和解题流程</h3>
            
            <p>为了搞懂动态规划，必须在这做记录：动态规划永远是根据已经走过的路，计算走到今天付出的代价</p>
            
            <p>动态规划就四个步骤：</p>
            
            <ol>
                <li><strong>定义子问题</strong>：
                    <ul>
                        <li>子问题一定和原问题类似，且规模更小的问题，往往都是参数化的，参数就与问题的规模有关</li>
                        <li>父问题一定与子问题有关，也就是能根据已知的子问题解出规模更大的父问题</li>
                    </ul>
                </li>
                <li><strong>写出子问题的递推关系</strong>：
                    <ul>
                        <li>假设子问题已经被解决了，那么当前的问题应该如何解决（常见关系：max 选择，求和转移）</li>
                        <li>加上边界条件（最初的子问题）</li>
                    </ul>
                </li>
                <li><strong>确定 DP 数组的计算顺序</strong>：
                    <ul>
                        <li>大部分 DP 问题都是基于数组进行顺序迭代的</li>
                        <li>极少部分 DP 问题是基于递归进行备忘录求解的</li>
                    </ul>
                </li>
                <li><strong>空间优化</strong>：
                    <ul>
                        <li>是否能够空间优化其实可以在写出子问题的递推关系的时候发现，如果关系式的参数是有限且临近的，那在迭代问题中就可以被临时变量代替了</li>
                        <li>哪些动态规划问题不能空间优化？我称之为长记忆问题，也就是子循环递推问题，这类问题求解父问题需要遍历之前的所有子问题</li>
                    </ul>
                </li>
            </ol>
            
            <p>遇到任何动态规划问题，都是对子问题的分析，对子问题的确定需要依托子问题和父问题的信息传递，即子问题的解决必须能减轻父问题的负担，这样的问题才是子问题</p>
            
            <h3>DP 问题分类大观</h3>
            
            <table>
                <thead>
                    <tr>
                        <th>问题特征</th>
                        <th>可能类型</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>涉及数组/字符串的<strong>单个序列</strong>操作，状态与序列位置直接相关（仅依赖序列前驱）</td>
                        <td><strong>线性DP</strong></td>
                    </tr>
                    <tr>
                        <td>涉及<strong>两个序列</strong>的匹配或比较</td>
                        <td><strong>双序列DP</strong></td>
                    </tr>
                    <tr>
                        <td><strong>选择物品</strong>且有<strong>容量限制</strong>，状态定义中包含容量维度</td>
                        <td><strong>背包问题</strong></td>
                    </tr>
                    <tr>
                        <td>操作对象是<strong>区间或子序列</strong>（需枚举分割点）</td>
                        <td><strong>区间DP</strong></td>
                    </tr>
                    <tr>
                        <td>问题在<strong>树形结构</strong>上操作</td>
                        <td><strong>树形DP</strong></td>
                    </tr>
                    <tr>
                        <td>存在多个<strong>互斥状态</strong>，状态间有明确的转移规则。</td>
                        <td><strong>状态机DP</strong></td>
                    </tr>
                </tbody>
            </table>
            
            <h4>线性DP：单序列问题</h4>
            
            <p><strong>核心特点</strong>：状态与序列位置直接相关</p>
            
            <p><strong>经典问题</strong>：最长递增子序列（LIS）、最大子数组和</p>
            
            <p>🎯 <strong>状态定义套路</strong>：</p>
            
            <ul>
                <li><code>dp[i]</code>：<strong>以第 i 个元素结尾</strong>的某种最优解</li>
            </ul>
            
            <h5>连续子数组问题</h5>
            
            <p>状态定义：<code>dp[i]</code>：以第 i 个元素结尾的最大子数组和</p>
            
            <p>状态转移：<code>dp[i]=max(nums[i], dp[i-1] + nums[i])</code>：要么尾追，要么单开</p>
            
            <p>空间优化：因为只关注前驱，只保留 <code>pre</code> 即可</p>
            
            <p><a href="https://leetcode.cn/problems/maximum-subarray/description" target="_blank">53. 最大子数组和 - 力扣（LeetCode）</a></p>
            
            <p><strong>问题</strong>：找出一个具有最大和的连续非空子数组</p>
            
            <div class="code-container">
                <div class="code-tabs">
                    <button class="tab-btn active" data-lang="cpp">C++</button>
                    <button class="tab-btn" data-lang="python">Python</button>
                </div>
                
                <div class="code-blocks">
                    <pre class="code-block active" data-lang="cpp"><code class="language-cpp">int maxSubArray(vector<int>& nums) {
    vector<int> dp(nums.size());
    dp[0] = nums[0];
    int maxn = dp[0];
    for(int i=1;i<nums.size();i++){
        dp[i] = max(nums[i],dp[i-1]+nums[i]);
        if(maxn<dp[i]) maxn=dp[i];
    }
    return maxn;
}</code></pre>
                    
                    <pre class="code-block" data-lang="python"><code class="language-python">def maxSubArray(nums):
    dp = [0] * len(nums)
    dp[0] = nums[0]
    maxn = dp[0]
    for i in range(1, len(nums)):
        dp[i] = max(nums[i], dp[i-1] + nums[i])
        maxn = max(maxn, dp[i])
    return maxn</code></pre>
                </div>
            </div>
            
            <!-- 更多内容省略... -->
        </section>
    </main>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js"></script>
    <script src="script.js"></script>
</body>
</html>